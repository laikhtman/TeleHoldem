TeleHoldem Poker UI Implementation & QA Plan
1. Information Architecture
Primary Game View: A single page (e.g. PokerGamePage in client/src/pages/poker-game.tsx) containing the table and all UI overlays. This view includes:
Poker Table Region: Visual representation of the poker table (oval background) with 6 PlayerSeat components arrayed around it (6-max only for v1). The table also contains the CommunityCards area at the center and a PotDisplay near the center/top.
Action Bar: A persistent bottom region with ActionControls (Fold/Check/Call/Bet/Raise/All-in buttons) or a “Start New Hand” button when the game is in waiting state. This bar spans the full width and sits above the device’s home indicator (using bottom safe-area insets
core.telegram.org
).
Hand Strength Panel: A left-side panel showing the player’s current hand strength or odds. Hidden entirely on narrow screens; available via a toggle on medium screens; and shown as a sidebar on large screens (see Breakpoints).
History/Stats Panel: A right-side panel showing hand history, recent actions or player stats. Hidden on mobile; shown as a persistent sidebar on desktop (large screens).
Overlays and Toasts: Floating UI elements for transient feedback or menus: e.g. an in-game toast message (e.g. “You won the pot!”) that appears at the top center, and modal overlays such as a rules dialog or settings (if any). Toasts use position: fixed and aria-live="polite" for screen readers (to announce events).
Bottom Sheet (Mobile): For small viewports, a MobileBottomSheet component is used to show auxiliary content (hand strength or history) when requested. It slides up from the bottom, covering the table partially/full, and can be swiped down to dismiss.
Floating Action Menu: A round toggle (e.g. “⋮” or hamburger icon) that floats above the table (e.g. bottom-right corner). Tapping it expands a few quick-access icons (as mini-buttons) for secondary actions like “Toggle Hand Strength Panel”, “Show History”, or “Settings”. On phones, this is how users access the side-panel content (by opening the sheet via this menu). The FloatingActionMenu is only present on small screens where side panels are hidden.
Component Hierarchy & Ownership: The game page orchestrates layout: for example, a high-level structure could use CSS Grid or Flex to position side panels and table:
<div className="game-layout">
  {isLarge && <HandStrengthPanel ... />}    {/* left sidebar on lg+ */}
  <div className="table-area">              {/* main table container */}
     <TableBackground>…</TableBackground>
     <CommunityCards ... />
     <PotDisplay ... />
     {players.map(... => <PlayerSeat ... />)}
  </div>
  {isLarge && <HistoryPanel ... />}         {/* right sidebar on lg+ */}
</div>
<ActionBar> <ActionControls ... /> </ActionBar>
<FloatingActionMenu ... />                 {/* on mobile */}
<MobileBottomSheet ... />                  {/* on mobile */}
<Toasts ... />
In the above, HandStrengthPanel and HistoryPanel would render only at certain breakpoints. On medium screens (tablet), the HandStrength panel is not persistently shown in the layout; it’s toggled into view (likely as an overlay) when needed. The PlayerSeat components are absolutely positioned within the table container (positioned via script or CSS). We will reuse existing component files (e.g. PlayerSeat.tsx, CommunityCards.tsx, etc.) and refactor only if needed for clarity. The main page poker-game.tsx will remain the coordinator of game state to these UI components.
No Unused Views: Spectator/observer modes are out of scope for v1 – the UI assumes exactly 6 seats (no dynamic table sizes). There is no separate lobby or menu in this UI spec (it’s focused solely on the in-game interface). We ensure all UI elements described map to existing or new components in the repository.
2. Visual System and Tokens
Typography Scale: Use a responsive typographic scale to ensure readability on small devices
zignuts.com
. We define base font sizes per breakpoint and use Tailwind’s responsive utilities (and design tokens in index.css):
Extra small (<480px width) – Base font ~14px (e.g. text-sm); small labels/captions no smaller than 12px. Headers/titles ~18px.
Small (≥480px, default mobile) – Base font 15-16px (text-base); captions 13-14px; section headings ~20px.
Medium (≥768px) – Base font 16px; headings ~24px; large titles ~28px.
Large (≥1024px) – Base font 16px (may go to 17px for desktop); headings 28px; large titles ~32px.
These sizes ensure the main UI text meets the recommended 16pt body size for mobile apps
zignuts.com
. All text is set in relative units (rem) so it scales if the user adjusts browser zoom or OS font size. We avoid any text below 12px to maintain legibility on high-density screens.
Color Tokens: Leverage the theme CSS variables defined in client/src/index.css for consistent color usage. The design will use a dark-poker-table aesthetic by default (dark mode), but we support light mode via tokens. Example tokens (from Shadcn/UI) and their usage:
--background / --foreground: Base background (e.g. table felt color) and foreground text color. In dark theme, background might be a deep green or charcoal and foreground is light gray/white; in light theme, background could be pale beige and text nearly black (ensuring 4.5:1 contrast
webaim.org
).
--card / --card-foreground: Surface color for panels/cards (e.g. slightly lighter/darker than table for contrast).
--brand-500/600: Accent color for primary actions. We will use the existing “brand” hue (e.g. blue as placeholder) for actionable highlights (e.g. Raise button background). For example, bg-brand-600 uses the CSS HSL value defined for brand
infinum.com
.
--destructive: Accent for destructive/negative actions (e.g. Fold). Likely a red tone provided by the design system (if not, we define one that meets contrast on dark bg).
--success / --warning: Colors for positive or warning states (e.g. winning hand highlight in green, alert in yellow/orange).
These tokens are already mapped to Tailwind classes (via bg-[hsl(var(--...))] or similar) in the Shadcn system
infinum.com
. We will use those utilities rather than raw hex values, ensuring easy theming.
Spacing & Sizing: Adopt an 8px base grid for spacing. We’ll use Tailwind spacing utilities (which correspond to values in index.css theme if configured). For instance, small gaps = 4px (gap-1), default component padding = 8px (p-2), larger padding for modals/panels = 16px (p-4), etc. We ensure consistent spacing between buttons in the action bar (at least 8px separation) and around the table (outer margin to screen edges accounting for safe areas). All interactive controls meet or exceed 44x44px (~48px) touch target
ux.stackexchange.com
 – e.g. action buttons have min-w and min-h of 48px, and additional padding if needed for icons inside.
Radii & Elevation: Use the design tokens for border-radius to ensure a cohesive style
infinum.com
. For example, apply rounded-md (≈6px radius) on buttons and panels, rounded-lg (12px) on the table corners or modals, and rounded-full on circular elements (player avatars, chip icons). The poker table itself might use an oval shape: we can achieve this with CSS (border-radius: 50%/5% for an extreme oval, or use an SVG backdrop). We will likely use a subtle box-shadow or elevation for floating elements: e.g. the action bar and bottom sheet have a slight shadow (Material elevation 2) to distinguish from background. Use Tailwind shadow-md or shadow-lg with appropriate color (maybe using opacity tokens) for pop-outs. A backdrop blur is applied to modals/overlays if needed (e.g. using backdrop-blur-sm on overlay) to indicate focus. All state layers and shadows will use transform and opacity changes (no heavy paint effects) to maintain performance.
Interactive State Styles: Follow Material Design’s state layering approach
ux.stackexchange.com
 for hover, focus, pressed, and disabled:
Hover (desktop only): Buttons and interactive items get a slightly lightened or darkened overlay on hover (e.g. 8% white overlay on dark buttons, or 8% black on light buttons) to cue interactivity
ux.stackexchange.com
. No hover effect on mobile.
Pressed: On tap or active state, we use a deeper state-layer overlay – e.g. 12-20% opacity of content color over the component
ux.stackexchange.com
 – to show the pressed effect. Additionally, for important buttons we’ll slightly scale down (e.g. 0.98) on press using CSS or Framer Motion for tactile feel.
Focus (keyboard focus-visible): Any element that can be tabbed to will show a focus ring. Use Tailwind’s focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-brand-500 (for example) to produce a 2px ring in the brand color with a small offset. This ensures a high-contrast focus indicator (aiming for ≥3:1 contrast with adjacent colors
ux.stackexchange.com
) so that keyboard users can easily see it.
Disabled: Disabled buttons use the design system’s disabled style – typically lower opacity (50%) and no hover/active effects. We will apply opacity-50 cursor-not-allowed via Tailwind when a control is disabled. The color tokens will ensure disabled text still meets contrast (if not, we might adjust the token, or provide an underline for links, etc., but generally using 50% of a bright color on dark still yields some contrast). Disabled elements will be removed from keyboard/tab order where appropriate (e.g. disabled attribute on <button> naturally does this).
All these styles will be implemented using our existing Tailwind classes which are linked to theme tokens, ensuring consistency and easy adjustments across light/dark modes
infinum.com
. For example, a Fold button might use bg-destructive/80 hover:bg-destructive text-white rounded-md to get a red background (80% opacity) that becomes solid on hover, with white text for contrast.
3. Layout and Breakpoints
Our layout adapts to three key viewport categories: mobile (<768px), tablet (768–1023px), and desktop (≥1024px). We use CSS media queries or Tailwind breakpoints to implement the following exact behaviors:
Table Container Aspect Ratio: The table area maintains a specific aspect ratio depending on screen width for an optimal look:
Viewport width < 480px: use ~1.9:1 width:height ratio (very wide and short) – e.g. a 320px wide screen yields ~168px tall table.
Width 480px–767px: use ~1.85:1 ratio (slightly less wide relative to height).
Width ≥ 768px: use 3:2 (1.5:1) ratio (more balanced for larger displays).
We will implement this via CSS. For example, define utility classes or style rules: .table-container { aspect-ratio: 1.9; } @media (min-width:480px){ .table-container{ aspect-ratio: 1.85;} } @media (min-width:768px){ .table-container{ aspect-ratio: 3/2;} }. (Tailwind can be extended with a custom xs:480px breakpoint for this, or we use a manual CSS snippet.) Additionally, we cap the table’s height to avoid it dominating shorter viewports: set max-height: 80vh on the table container. This prevents issues on desktop windows (e.g. 1280×800) where a 1.5:1 ratio at full width would demand 853px height which wouldn’t fit. With max-h:80vh, the table will scale down if needed to ensure the whole UI fits without vertical scrolling. We also include padding around the table per safe-area insets (see below).
Safe-Area Insets: The layout accounts for device notches and home indicators using CSS env vars
core.telegram.org
. In index.css we have variables like --safe-top, --safe-bottom etc., mapped to env(safe-area-inset-*). We apply these as padding/margin where appropriate:
The Action Bar at the bottom gets padding-bottom: var(--safe-area-inset-bottom) so that on an iPhone with a home indicator, the buttons sit above it
core.telegram.org
. This padding is in addition to the 8px or so of regular spacing. Similarly, top UI elements (if any) would use padding-top: env(safe-area-inset-top) to avoid notches (for example, if we had a top status bar or if community cards are near the top edge, we might push them down slightly within the table container). We will ensure the table container itself has padding-top: var(--safe-area-inset-top) and padding-bottom: var(--safe-area-inset-bottom) so that no seat or card is rendered under a notch or too close to screen edges. (This is crucial for Telegram’s full-screen mode as well
core.telegram.org
.)
Left/right safe insets (for curved screen edges or landscape) are less critical, but if the device provides non-zero safe-area-inset-left/right, we can apply those to a parent container so that content isn’t cut off. For example, add padding-left: env(safe-area-inset-left) on the main container when in landscape on iPhone.
Player Seat Placement: Seats are positioned in an elliptical formation within the table container. We calculate seat coordinates dynamically to scale with container size: for 6 seats, we position them at equal angular intervals around an ellipse. Specifically, define an ellipse centered at (50%, 50% of the table container) with radiusX ~45% of container width and radiusY ~45% of container height. Seat centers are placed at angles (from vertical axis) of 90°, 150°, 210°, 270°, 330°, 30° (this sequence going clockwise places one seat at bottom center (90°), one at bottom-left (150°), one at top-left (210°), one at top center (270°), one at top-right (330°), and one at bottom-right (30°)). This symmetric layout ensures no seat is directly at the extreme left/right, favoring a portrait orientation. In implementation, for each seat i (0–5) we can compute:
const angleDeg = 90 + i*60;
const angleRad = angleDeg * Math.PI/180;
const x = 50 + (Math.cos(angleRad) * 45); // percent from center
const y = 50 + (Math.sin(angleRad) * 45);
Then apply position: absolute; left: x%; top: y%; transform: translate(-50%, -50%); to each PlayerSeat so that its center aligns to that point. This way, seats automatically spread out as the table grows, maintaining an oval distribution. Ellipse constants: 45% is a starting point that leaves ~5% padding to the edge; we can fine-tune if needed (e.g. 40–45% range) to ensure seat UI (which has its own width) never touches the table edge. This formula will be coded in PokerGamePage or a layout util. We will test across devices: on small screens the seats will cluster closer due to narrower width (which is fine), and on tablets/desktops, seats will be more spaced. If extremely wide screens cause seats too close to edges, we might clamp radiusX to a max pixel value. For v1, the above percentages suffice.
Hand Strength Panel (Left side):
<768px (mobile): Panel is fully hidden. It is not rendered persistently. Users on mobile will access this via the FloatingActionMenu (which opens the bottom sheet). So in portrait mobile, the panel content appears only in a modal bottom sheet on demand (taking full screen width in that case).
768px ≤ width < 1024px (tablet, “md” range): Panel is available but not docked open by default. We provide a toggle button (for example, a small graph icon in a corner or a slide-out handle at left edge). When the user taps this, the HandStrength panel slides in as an overlay. On a medium tablet (e.g. iPad portrait, 768px width), showing the panel over the table will cover a significant portion, so the panel likely floats above the table (perhaps ~320px width overlay from the left) and can be closed to return to full table view. The toggle can be implemented as a persistent icon near the bottom left of the action bar or on the left edge of screen.
Behavior: tapping toggle opens the panel as a drawer (covering ~40% of screen width from the left). The table remains visible to the right (possibly partially obscured). The panel has a semi-transparent backdrop on the table area or an obvious edge, and a close button. This is effectively a modal in terms of interaction (focus should move into it, etc.). On medium screens, the user is likely to open it between hands or when needed, then close.
≥1024px (desktop, “lg” range and up): The HandStrength panel becomes a persistent left sidebar. It occupies a fixed column (e.g. 300px wide) on the left of the table. The table is then rendered in the remaining space to the right. In this mode, the panel can remain open at all times (“sticky”). We will implement this by switching the layout to a 3-column grid/flex at lg. The panel’s content scrolls internally if needed, but the panel itself stays visible as the main viewport doesn’t scroll. We may allow collapsing it via a UI control (for user preference), but by default it’s shown.
Internally, we’ll manage this with CSS classes: e.g. hidden md:block lg:basis-72 for the panel element, and JavaScript to handle the overlay mode on md (show/hide with a state).
History/Stats Panel (Right side):
<1024px: Completely hidden and not accessible (to keep scope manageable – mobile users won’t see the full history in v1). Optionally, we could allow access via the FloatingActionMenu similar to the left panel (e.g. an icon for history that opens a bottom sheet). This is a nice-to-have; but given the spec says “hidden < lg”, we will not expose it on small screens for now to reduce complexity (OK for v1).
≥1024px (lg+): The history/stats panel appears as a right sidebar. We allocate a column (e.g. 240–300px wide) on the right side of the screen for this panel. It will have a scrollable list of past actions or hands. It is “sticky” in the sense it remains on-screen. The main table area is centered between the two side panels on large screens. For layout, we’ll likely use grid-cols-[auto,1fr,auto] at lg breakpoint, where the side columns are auto-sized to e.g. their content or a fixed width. The History panel does not need a toggle on desktop; it’s always shown. (We can include a hide/minimize button if we anticipate users wanting to hide it, but the spec implies it stays visible.)
Responsive Table Scaling & Paddings: The table area (the center column in large layout) will shrink when side panels are present. We ensure the aspect ratio rules still apply within that available space (the max-width of table could be something like calc(100% - 300px - 300px) on desktop). We also ensure some margin around the table so that player seats or pot don’t butt up directly to side panels or screen edges. For example, on mobile, we give the table container horizontal padding ~max(16px, env(safe-area-inset-left)) so outer seats aren’t cut off. On larger screens, the side panels themselves provide spacing; still, a small gap between table and panels (perhaps 16px) will be added. No element should touch a screen edge or panel border without at least 8px padding.
Seat Scaling and Overlap: The PlayerSeat components (avatars/chip counts) will scale their contents (font sizes etc.) for different breakpoints to avoid overlap. For instance, on very small screens, seat name text might use text-xs (12px) to fit in the seat UI, whereas on desktop it can be text-sm or md. We will ensure that at the smallest configuration (6 players on a 320px wide screen), seats do not overlap each other or the community cards: the chosen ellipse and seat sizing should accommodate this. We’ll test on iPhone SE resolution specifically for any overlap. If needed, we might slightly adjust the angular positions or radius for that extreme case (e.g. bringing top seats slightly lower). The goal is clear separation between each seat UI.
By adhering to these breakpoint rules and layout strategies, the design will be mobile-first responsive
yaninagames.com
 – starting optimized for portrait phones, and gracefully expanding to use extra space on tablets and desktops.
4. Component Specs (APIs & Behavior)
Below are specifications for each major UI component, including props (inputs), expected rendering, interaction handling, and edge cases:
PlayerSeat Component (client/src/components/PlayerSeat.tsx)
Purpose: Displays a player’s status at the table: typically includes avatar (or placeholder), player name, chip stack, and indicators (dealer button, turn highlight, etc.).
Props: We anticipate props like:
playerId (string or number) – unique ID.
name (string) – Player display name (will be truncated if too long).
chips (number) – Current chip count for the player.
isDealer (boolean) – True if this player has the dealer button (we’ll render a small “D” icon in their seat).
isCurrentTurn (boolean) – True if it’s this player’s turn to act (used to highlight the seat).
hasFolded (boolean) – True if the player has folded in the current hand (affects appearance).
isAllIn (boolean) – True if player has no chips remaining in the hand (all-in state).
Possibly avatarUrl or avatarInitial (for avatar image; if not provided, we show initials or a generic icon).
All props except playerId are optional in that a default can be assumed (e.g. if no name, show “Empty Seat”). In practice, we will always have a player object for each seat in game state.
Rendering: The seat is typically a circular or rounded container positioned around the table (position comes from parent as discussed). Inside, it might show an avatar image on top, and a text label for name and chips below or overlaying. We will likely use a vertical stack: Avatar at center, name below it, chip count below name. The component should size itself responsively (e.g. on mobile, maybe 60px diameter avatar, on desktop 80px). We can use Tailwind’s responsive classes for that (w-12 h-12 md:w-16 md:h-16 for avatar, etc.).
Visual States:
If isCurrentTurn, the PlayerSeat gets a glowing ring or highlight border. Implementation: a CSS animation pulsing the border color (using the accent color, e.g. bright green or blue) and/or a subtle radial glow behind the avatar. This draws attention to whose turn it is
yaninagames.com
. The glow will be an effect on the seat container (e.g. box-shadow: 0 0 8px 2px #fff accent, animated).
If hasFolded, the seat is visually deemphasized: we’ll dim the avatar (e.g. apply opacity: 0.5 or a grayscale filter) and maybe italicize or gray out the name/chip text. Possibly also overlay a small folded card icon or “X” on the avatar to indicate a fold. This state persists until the next hand.
If isAllIn, we display an All-In label or icon on the seat. For instance, a small red triangle or “ALL-IN” badge near their chip count. Also, if all-in, the chip count will not decrease further (they can’t bet more). We might also want to highlight all-in players by a different border (e.g. gold glow) briefly when they go all-in, but the main indicator is the badge.
If isDealer, show a dealer button (small white disk with “D”) positioned at the top/right of the seat or next to the avatar.
Default: for players still in hand but not currently active, just show normally (avatar, name, chips). For empty seat (if that case existed, but we lock to 6 players in v1, so no empty seats scenario).
If a player is disconnected/offline (not explicitly tracked in v1, but if we had it), we could dim them similarly to folded and perhaps a red “offline” dot. (Out of scope as no spectators.)
Interactions: PlayerSeat is largely a display; it is not clickable in the current scope (we’re not implementing any profile or context menu on tapping a player). We will set pointer-events: none on the seat except perhaps the dealer chip could have a tooltip (not needed). In future, we might allow clicking a seat to view player profile, but v1 no action. So no focus or keyboard interaction needed for seats (they should be skipped in tab order).
Accessibility: We will give the seat container an ARIA label that summarizes the player’s status for screen readers. For example: aria-label="Player ${name}, ${chips} chips${hasFolded? ", folded":""}${isAllIn? ", all-in":""}${isCurrentTurn? ", current turn":""}". This way a screen reader user can explore the table and hear each player’s info. (We might assign role="group" on the seat and separate labels for name and chip count as well, but a single label is concise). The avatar image will have alt="" (decorative, since the name conveys identity). The seat highlight or dealer icons are purely visual, but their meaning is included in the aria-label text (e.g. “dealer” or “current turn” as above). This ensures no essential info is lost to non-visual users.
Animation: If a new card is dealt to this player, we might animate the card arriving at their seat (that animation will be handled by the PlayingCard components or a dealer function, not within PlayerSeat per se). But PlayerSeat may animate certain state changes: e.g. when isCurrentTurn becomes true, we can trigger a quick pulse or glow onset (no abrupt flash). When a player wins a pot, we might flash their chip count or highlight the seat (e.g. gold glow) briefly. These can be done with CSS transitions on a state change (tailwind classes toggled) or small Framer Motion animations (e.g. animate an increase in chip count with a number roll effect, etc.). We’ll prioritize essential animations: turn indicator pulse (continuous) and perhaps a win highlight for 2s.
Props Example Usage:
<PlayerSeat 
  name="Alice" chips={1500} 
  isDealer={true} isCurrentTurn={false} hasFolded={false} isAllIn={false} 
/>
This would render Alice’s seat with dealer button. In contrast:
<PlayerSeat 
  name="Bob" chips={0} 
  isCurrentTurn={true} hasFolded={false} isAllIn={true} 
/>
would show Bob with an all-in badge, highlighted turn (if he’s all-in and it’s effectively his “turn” no action though). We will ensure combination states (e.g. folded + dealer) still display sensibly (likely folded overrides and dims everything including dealer icon).
PlayingCard Component (client/src/components/PlayingCard.tsx)
Purpose: Renders a single playing card – can be used for a player’s hole card or a community card. Supports face-up (showing rank/suit) or face-down (card back). Possibly also used for deck animations.
Props:
rank (string) – e.g. "A", "K", "10", etc.
suit (string) – e.g. "hearts", "spades", etc.
faceUp (boolean) – whether the card is revealed. If false, we show the card back design.
highlight (boolean, optional) – highlight the card (e.g. if part of winning hand, might glow).
We might also accept a style or positioning props if we animate it, but normally the parent (CommunityCards or PlayerSeat) positions it.
If using sprite or SVG for cards, props may include the resource. In our implementation, we might use an SVG for suits and text for rank, or a pre-rendered image per card.
Rendering: If faceUp is true, display the card face: show rank and suit symbol with appropriate color (♥♦ in red, ♣♠ in black). We’ll likely implement cards via a combination of Tailwind and perhaps an SVG: e.g. a card div with white background, border, slight border-radius (4px), aspect ratio ~1:1.4, containing top-left rank and bottom-right rank (rotated) and a large suit symbol centered. To simplify, we might use an image sprite sheet for card faces. But given this is UI, we can also render text. For v1, clarity is key, so large symbols and legible letters. The component’s size can be fixed (like width 40px, height ~56px on mobile, scaling up to maybe 60×84 on desktop for community cards). We’ll adjust via CSS classes at breakpoints (e.g. w-10 h-14 on mobile, w-14 h-20 on desktop). If faceUp=false, render the card back: use a textured back image or a flat design (maybe the TeleHoldem logo or a pattern) – we will ensure the back design contrasts with table (maybe blue or gray). The card back can be an asset or a simple colored rectangle with a logo.
Interactions: For the player’s own hole cards, we support a tap gesture to “peek” at them. This is a common UX in mobile poker: tapping or long-pressing your facedown cards slightly raises or enlarges them for you. Implementation: when user taps on their card, if faceUp is false (meaning card is face-down to them, which typically it isn’t – the user always sees their own cards face-up in online poker), so more relevant is if they want a better view, we could enlarge. But since in our game the user’s cards will be face-up to the user, a peek isn’t needed to reveal (they are already revealed to the user). Instead, we can allow a flip animation on tap for fun (flip down and up quickly) or a slight lift. This is low priority. For v1, the PlayingCard has no required interactive behavior except possibly to facilitate the fold gesture (see Gestures: swiping a card). However, we do implement swipe: If the user swipes their own cards upward (a “throw away” gesture), we interpret that as a fold action (with confirmation if needed). The PlayingCard component for hole cards will have a touch handler: on touch-move, if the finger moves upward ~50px and releases, we emit a fold action. (We’ll ensure this only triggers on the user’s turn and not after they’ve already folded, etc. and perhaps require a swift flick to avoid accidental drags.) This gesture is informed by patterns (e.g. flick up to fold in some apps
medium.com
). The card component itself might use draggable={true} with Framer Motion so the card visually moves with the finger; if dropped beyond a threshold, we fold (and animate the card flying off table). This interaction will be implemented carefully to prevent accidental folds (perhaps require a quick flick rather than a slow drag).
Animation:
Dealing Animation: When a card first appears (dealt to a player or to the community), we animate it coming from the “deck” position. We will likely treat the deck as the center of the table. In practice, in the UI, we can create the card at the table center (with position: absolute at center) and then transition it to its target position (the parent seat or community slot) over ~0.5s. Using Framer Motion, we can set initial { left: 50%, top: 50% } on the card and animate to { left: finalX, top: finalY }. We’ll include a slight easing-out so it looks smooth. Only one or two cards move concurrently to maintain 60fps (deal sequentially).
Flip Animation: For community cards (flop/turn/river) and possibly the hole cards at the start, a card turning face-up will be animated. We implement this as a 3D rotation: using Framer or CSS transitions: e.g. .card { transition: transform 0.3s; transform-style: preserve-3d; } .card.face-up { transform: rotateY(0deg); } .card.face-down { transform: rotateY(180deg); }. When faceUp prop changes from false to true, we animate the rotateY from 180 to 0 (with a 0.3s ease-in). We will likely have to swap the card face/back at the 90° point (halfway) – using either two <div>s front/back or using backface-visibility hidden. Framer Motion’s animate can handle it by animating a rotateY value. We’ll coordinate the state change with the animation so that the face graphic is visible at the right time. This yields a nice flip effect for the flop reveal, etc.
Highlight Animation: If highlight=true (for example, highlighting the winning hand’s cards at showdown), we might apply a gentle glowing border or a slow blink on those cards. This can be done with CSS animation (a pulse of border-color or box-shadow). This state would be toggled at round end for the winner’s cards, then removed.
Accessibility: Each card has an aria-label reflecting its value, but careful: For the user’s own cards and community cards, we want screen readers to know what they are. We can do aria-label="Ace of Hearts" for a face-up card. For face-down cards (e.g. opponents’ hole cards not visible), we label them "Face down card" and possibly hide them from SR if not relevant. Community cards might be grouped with an aria label on the container (like "Board: Ace of Hearts, 7 of Clubs, ..."). We will ensure the important cards are announced when flipped or dealt: e.g., after the flop is dealt, we could use a live region to say "Flop: A♥, 7♣, 7♠". This might be part of game engine messaging. For now, static labeling of the elements will do. The PlayingCard component itself could have role="img" with alt text equal to the card name for simplicity.
Example Usage:
<PlayingCard rank="K" suit="spades" faceUp={true} />
shows the King of Spades face-up.
<PlayingCard faceUp={false} />
would render a card back (rank/suit not needed because hidden). If suit and rank are passed while faceUp=false, the component can ignore them. We’ll likely have an enum or constants for suits for easy mapping to glyphs or colors.
Performance: We minimize re-renders by not animating with heavy reflows. The use of transforms for moving and flipping cards ensures GPU-accelerated animations. Also, we batch deal animations so we don’t have 6 cards animating at once – dealing will be one card after the other with maybe small overlap. Each card element is fairly lightweight (some text or a small SVG). No continuous animations on cards except a possible subtle idle animation on the deck or such (not required).
ActionControls Component (client/src/components/ActionControls.tsx)
Purpose: Renders the action buttons for the current player to interact with the game (Fold, Check, Call, Bet, Raise, All-in, etc.). It appears in the action bar at bottom center when a hand is in progress. In a waiting state (no active hand), this component might be hidden in favor of a “Start New Hand” button or similar.
Props: It likely takes game state info to decide which buttons to show/enable. Props may include:
canCheck (boolean) – True if no bet is currently required (so the player may check instead of call).
callAmount (number) – Amount to call (0 if none).
minRaise (number) – Minimum amount if raising (for label or slider reference).
currentBet (number) – Current highest bet on table (0 if none).
playerChips (number) – The player’s remaining chips (to know if all-in is possible).
phase (string) – Game phase, e.g. "preflop", "flop", etc., or "waiting".
These could also be derived via context rather than explicit props; in any case ActionControls will need to know the relevant information to configure the buttons. If phase === 'waiting' (no active hand), ActionControls might render the “Start New Hand” button (which in code might actually be outside this component, but we can handle it here).
Behavior & State Logic: Only show valid actions – no inactive buttons that do nothing. This is to streamline the UI and avoid confusion (common pattern in poker UIs is to hide or disable actions that aren’t applicable). Specifically:
When it’s not the user’s turn or the user is not in the hand (folded), no action buttons should be active. We will disable them or hide them entirely. (Likely we’ll hide to avoid clutter – since the user can’t act, and we might show “Waiting for others...” text instead). In our one-player scenario (if single-player vs AI), it’s always the user’s turn when ActionControls is shown. In multi, we manage enable/disable based on turn.
Fold: Show whenever the player is currently in the hand and can fold (from pre-flop through river). If the player has already checked and there’s no bet, fold is technically equivalent to check-fold; we may still show it if they want to pre-fold to any future bet. For v1, fold button is visible on player’s turn if they haven’t already folded. We will disable or hide it when the player is all-in (no choice to fold) or if the hand is over.
Check vs Call: We show one or the other, not both. Use canCheck: If canCheck === true (no bet to match), render a Check button. If canCheck === false, render a Call button with the call amount. The label should include the amount: e.g. “Call 100” so the user knows the size
yaninagames.com
. If the amount is 0 (no bet), that button might actually say “Check” which is handled by the canCheck logic. We ensure the label updates dynamically if the bet amount changes while it’s the user’s turn (though usually it won’t mid-decision).
Bet vs Raise: If currentBet === 0 (no bet on table), use Bet. If currentBet > 0, use Raise. The behavior on click for Bet/Raise will open a bet-sizing interface or if not implemented, at least trigger a minimum bet. In v1, to keep it simple, clicking Bet/Raise could just open a quick preset menu or automatically raise the minimum. (However, since we have an All-in button separately, Bet might just bet a default, e.g. half-pot for now). We will treat it as “Raise” means increase the stakes. The label might not show an amount unless we allow presets. We plan to implement a bet slider gesture instead of a full UI slider due to time – see gestures. For now, clicking Raise without further input could raise to a default (like min raise). We’ll document that as an interim behavior. In future, a proper slider or quick-buttons (half-pot, pot) can appear.
All-In: Always show if the player has chips remaining. This is a distinct action to push all chips. It’s effectively a raise to all chips or a shove. Many UIs hide the All-in if the raise slider can achieve the same, but here we keep it separate for quick access as per spec. All-in is disabled if the player is already all-in or if it’s not their turn.
Start Hand: When phase is 'waiting' (no hand dealt yet, table waiting to start), the ActionControls UI will instead show a Start New Hand button (centered). This button will only be enabled if conditions are met (e.g. at least 2 players with chips – but since vs AI presumably always yes). This button triggers the deal of cards/new round. As soon as a hand starts, this button is replaced by the regular action buttons.
We do not display invalid options: e.g. if there’s no bet, “Call” is meaningless – we won’t show a gray Call, we’ll show Check instead. Similarly, if the player has exactly the amount needed to call or bet, pressing Call or Bet might automatically put them all-in; we still label it “Call 100” etc. If playerChips <= currentBet and they call, that is technically an all-in call – we will handle that in logic but UI still just shows Call.
Layout & Sizing: The action buttons are arranged in a horizontal row within a container that likely has some translucency or distinct background (e.g. a dark strip) for contrast. We will ensure each button is at least 48px tall and wide
ux.stackexchange.com
. On smaller screens, if four buttons (Fold, Call, Raise, All-in) cannot fit comfortably side by side, we have a few strategies: we can either make them slightly smaller (but not below ~44px width each), or consider wrapping to two rows. Most 320px devices can fit four ~70px buttons (704=280 plus margins ~8px3=24 total ~304px, which fits in 320px). We will aim for button width ~25% each. If text labels get long (“Call 1000”), we might shorten e.g. “Call 1K”. We will also use flex spacing such that Fold and All-in might be slightly narrower (since they are short text) and Call/Raise a bit wider if needed to accommodate amounts. Tailwind: flex justify-between gap-2 etc. The container uses px-4 for padding and py-2 (plus safe-area padding bottom as above).
Styling:
Fold (Destructive variant): Red background (using bg-destructive token) with white text. On dark mode, this should be a vivid red that passes contrast on dark background; in light mode, likely a lighter red background with red text or still white text if dark enough – we’ll ensure it meets 4.5:1 either way. Hover/active: darker red or state overlay.
Check/Call (Primary default): We can style these as a primary action button – e.g. blue or green. Green is a common color for “go/call” in some UIs. We might use the theme’s brand color (if brand is blue, we could still use it for consistency). For clarity, using green for Call/Check might be nice (since fold is red = no, call is yes). But to simplify theming, we might stick to brand (blue) for all non-fold actions. We will confirm contrast: white text on brand-600 blue will likely be fine. Pressed state – slightly darker.
Bet/Raise (Primary or secondary): Could use the same style as Call to avoid confusion (all actionable buttons same style except destructive). Or we might style Bet/Raise in a highlight color (e.g. orange/yellow) to draw attention to betting. PokerStars, for example, often uses a slider with presets rather than coloring the raise button differently. We’ll likely keep a unified style for Call/Raise to minimize the user having to decode color-coding. (Alternatively, make Raise also brand color, or slightly different shade). Spec doesn’t require distinction, so we use the same class as call. Label will differentiate it.
All-in: This is a critical action. We could style it distinct (e.g. purple or gold). However, having too many colors can be distracting. Another approach: make All-in a secondary style button – e.g. an outline or black background if rest are colored. But that might downplay it. We actually want all-in to stand out (because it’s dramatic). Perhaps use an orange fill for All-in. Orange often indicates high emphasis (but not error). We must check contrast on both themes. Using the warning color could work (if defined). If not, we might use a variant of the brand (e.g. brand-700). For now, let’s assume All-in uses the destructive style as well (red) to indicate it’s an irreversible big action (some apps do show All-in in red). However, since fold is already red (negative), having All-in also red might confuse meaning. Another option: style All-in with a golden yellow to celebrate the boldness. If our theme has an accent that fits, we use it. We will ensure text contrast (likely black text on yellow if bright background, or white text on a dark gold).
All buttons will have consistent shape (rounded-md). Iconography: not strictly needed since text is clear, but we could use icons (fold icon of a hand or an X, etc.) alongside text if there's room. Probably skip for v1.
Keyboard Shortcuts: We implement the following global shortcuts for desktop play: F = Fold, C = Check/Call, R = Bet/Raise, A = All-in. These keys are chosen as mnemonics (and match common online poker hotkeys). The ActionControls component (or parent page) will listen for keydown events. Only if it’s the user’s turn (ActionControls is active) do we trigger actions on these keys. For example: pressing “F” immediately triggers the fold action as if the button was clicked. We will add an info tooltip or simply rely on user knowledge for these shortcuts. (For accessibility, these are in addition to focus + Enter on the buttons). We’ll ensure that if a text input or other component is focused, these keys won’t inadvertently fire (but we have no text inputs in game, so it’s fine).
Swipe Gestures: On mobile, the user can perform swipe gestures as shortcuts (in addition to tapping buttons). Following known patterns
medium.com
pokerfuse.com
:
Swipe right (from left to right) – interpret as Call/Check. (Rationale: a rightward motion could signify moving chips into the pot, which is akin to calling. Alternatively, some might map swipe up to fold and double-tap to check – but we have double-tap for check already. We choose a horizontal gesture for call to avoid conflict with vertical fold gesture.) We’ll implement: if the user swipes right in the action bar region or on the table, and it’s their turn, we trigger the call.
Swipe up – interpret as Fold. A quick upward “flick” of the cards (or anywhere upward) will fold
medium.com
. We specifically implement this by enabling dragging on the user’s hole cards (PlayingCard) upward (as described earlier). If the user flicks their cards upward beyond a threshold, we auto-fold and remove the cards with an animation (the card flying off). This gesture will be clearly documented to the user (perhaps in a tutorial or hint) to prevent mistakes.
Double tap – interpret as Check (or Call). If the user double-taps anywhere on the table (or on the screen) when it’s their turn, and if they have the option to check or call, we take that action
pokerfuse.com
medium.com
. Specifically, if no bet is needed (canCheck true), double-tap = Check; if a call is needed, double-tap = Call. This is convenient for one-handed play. We will attach a double-tap listener on the main container. (We’ll need to ignore double-taps on specific UI elements like toggling panels perhaps – but likely fine). We’ll implement using a timer or touchend detection for two taps within ~300ms.
Swipe left – (Optional) We could use left swipe for a lesser-used action like open the chat or settings if we had, but currently no such action. We’ll reserve it or ignore swiping left.
Swipe down – (Optional) could be used to open the bottom sheet or panel (like pulling up the hand strength panel from bottom on mobile). But since we have FloatingActionMenu, we won’t assign swipe-down in main area to anything (it might conflict with any pull-to-refresh or OS gestures, so best not to use down-swipe).
In summary, the key gestures are: double-tap = check/call, swipe-up = fold, and drag chip = raise (described below in betting). We’ll make sure these gestures do not conflict (e.g. a slow swipe vs. tap). Double-tap vs. single tap: single tap still activates buttons normally, double-tap anywhere else triggers check. Swiping up on cards will be distinct because the user will start touch on their card image and move.
Betting (Raise) Interaction: In v1 we will support two ways to raise: the Raise button itself, and a Drag-to-Bet gesture. The Raise button when tapped can either: (a) open a simple bet slider UI, or (b) directly raise a default amount. Given time, we will implement a simplified approach: tapping Raise immediately opens a minimal bet slider overlay (likely using the MobileBottomSheet on mobile or a small popover on desktop). This slider lets the user choose a raise amount from minimum up to all-in. The UI could be just a range input with preset buttons (Min, 1/2 Pot, Pot, Max). However, implementing this fully might be complex; as an alternative, we use a drag chips gesture: The user can drag their chip stack into the pot to indicate a raise
pokerfuse.com
. Implementation: The PlayerSeat (if it’s the user seat) will contain a draggable chip icon. When the user long-presses and drags it upward/rightward into the table, a bet amount increases. We can provide feedback by showing a ghost stack following their finger and maybe a floating number representing the bet size. If they drag all the way to the center, that indicates max (all-in). If they release at some point, we commit a bet of the corresponding size. This is similar to the Partypoker approach
pokerfuse.com
, and World Poker’s hold-and-drag for raise
medium.com
. For v1, a simpler variant: dragging the chip any distance could just mean “bet pot” or a fixed increment – but ideally we’d map distance to amount. We could define: distance (as % of some max radius) = % of chips to bet. E.g., dragging to pot center = 100% (all-in), half way = 50% of stack, etc. We’ll also incorporate haptic feedback as the user changes bet increments (using selectionChanged() feedback for each threshold crossed
core.telegram.org
). This is advanced; we’ll implement basic version: drag to pot = all-in (for simplicity in v1). If time permits, implement an actual slider. Regardless, the All-in button provides a one-tap way to shove without dragging.
Events/Callbacks: The component will call game logic callbacks when an action is taken. For example, it might accept prop callbacks like onFold(), onCall(), etc., or use a dispatch to game state. In testing, we’ll ensure the right game API is hit. The component itself doesn’t hold state beyond perhaps some local for the bet slider if implemented.
Accessibility: All action buttons will have descriptive text (and thus accessible name). We will also add keyboard accelerators in the title or aria-label (e.g. “Fold (F)”). In practice, screen reader users might not use those, but visible keyboard users see the UI hint. We will mark the container with role="group" and an accessible name like "Action buttons". If a button opens a slider (Raise), that slider will be focus-trapped and announced with instructions. For example, if Raise opens a bottom sheet with slider, the first element could be a heading “Choose raise amount” for context. The All-in button will have an extra confirmation in design? (We have not specified a confirmation dialog; likely not needed if user intentionally hits All-in – but accidental taps can happen. In v1, no confirm dialog, but we make sure All-in is somewhat separate to avoid accidental tap, e.g. spacing or maybe require double-tap? Not specified, so treat as normal but with maybe a distinctive color). If we find it risky, we might implement a long-press to all-in (common in some apps) – but not in spec, so skip.
Error/Edge States: If the user tries an action that’s not allowed (e.g. hits Call after timing out or when not their turn), the game server will likely ignore it. We will prevent that by disabling buttons appropriately. Another edge case is if user’s chip count is lower than call amount – then pressing Call actually puts them all-in for whatever they have. We handle this by game logic but UI will still label “Call 500” even if user has 300 (they will call with 300 which is all-in). To avoid confusion, we might change label to “Call 500 (All-in 300)” – but that’s too much detail for v1. We will simply allow the All-in button to cover that scenario: user can press All-in instead of call if they have less. But in a scenario where call amount > chips, effectively call = all-in; we will just show “Call 500” and it will result in all-in. (This is a known minor inconsistency, acceptable in v1). We ensure the All-in button is still present as it could be used even if not strictly needed (maybe to signify you want to go all-in over a smaller call).
CommunityCards Component (client/src/components/CommunityCards.tsx)
Purpose: Displays the community cards (shared cards on the table: flop, turn, river in Texas Hold’em).
Props:
cards (array of card objects or identifiers) – The community cards that have been dealt so far. Length will be 0 (pre-flop), then 3 (flop), 4 (turn), 5 (river). Possibly could have length 5 even before they are revealed if we pre-create slots, but better to drive by actual cards dealt.
We might also include stage (string) like "flop"/"turn"/"river" to know how many should be face-up. But easier: if the cards array length is N, we render N face-up cards. If we want to show unrevealed upcoming cards as back-face, we could always render 5 slots and flip them when available. However, standard UI doesn’t show unrevealed community cards at all (they just appear when dealt). We will follow that: only render what is dealt.
Possibly no other props; styling can be internal.
Rendering: The community cards are typically shown in a row at the center of the table (slightly above the pot). We will position this component absolutely at table center (or use flex in the table container to center them). The flop (first 3 cards) are spaced slightly apart horizontally (with maybe 8px between cards). Then the turn (4th) and river (5th) are placed to the right, with similar spacing. So effectively up to 5 cards in a line. We ensure the line is centered as a group. When fewer than 5 cards, it’s still centered (so the flop of 3 is centered on table). We can achieve this by always reserving space for 5 cards (e.g. a fixed width container) or simply center the container of N cards. We will just center the container. Each card is a PlayingCard component. For dealt cards (in cards array), we pass faceUp=true with the given rank/suit. For not-yet-dealt community cards, we do nothing (no face-down placeholders) for simplicity – the cards will “appear” when dealt (with an animation). If we wanted a more elaborate feel, we could show empty card backs in those slots from start, then flip them. But it’s not necessary and many UIs just show nothing until flop is dealt. We may choose to display card backs during the dealing animation only (like slide them then flip in one go). Simpler: spawn them at deal time.
Animations: When transitioning from one stage to the next:
Flop deal: Three cards will be dealt in quick succession to the center. We should animate them coming from the deck. Implementation: we might add cards one by one with a slight delay between (like card1 at t=0, card2 at t=0.1s, card3 at t=0.2s). Each card’s PlayingCard can have an entry animation (Framer Motion initial={{ scale:0.8, opacity:0, x:0, y:0 }} from center and animate to its position with scale:1, opacity:1). Or simpler, animate position from center to their offset. We’ll coordinate this via the game state change (when flop is dealt).
Turn and River: Each appears similarly, maybe with a short flip animation: e.g. the turn card could initially be rendered face-down at the correct position, then do a flip to face-up. But to keep consistent, we can animate them sliding from deck too (either approach is fine; sliding from deck is more consistent with card dealing if we imagine dealer always deals from center). We’ll implement deal from deck for every card.
Flip vs direct face-up: In some games, flop cards are dealt face-down then a dramatic simultaneous flip. However, in online poker it’s common they just appear face-up quickly one after another. We could do a quick flip for style: deal them face-down then flip all three together. This might be nice: e.g. at flop, deal 3 cards face-down (0.1s apart), then 0.3s after the last, flip all three face-up simultaneously. Turn and river can just flip on arrival (deal face-down, flip). This adds polish. We will try to implement that: the CommunityCards component can detect when a new card is added and if it’s part of flop, group flip. Possibly easiest: always animate new community card with a flip from face-down to face-up after it arrives.
Timing suggestions: each card travel ~0.4s, delay 0.1s, flip animation ~0.3s. We ensure these animations do not overlap excessively (maybe flipping happens after movement done to avoid jank).
Interaction: Community cards are not interactive. (No one can click them; they are purely informative.) So no tab-stop. We’ll set pointer-events: none on the container to prevent any accidental interactions.
Accessibility: The component should provide an accessible summary of the board. We can do: <div aria-label="Community cards: [list]" role="group"> and mark each PlayingCard as aria-hidden to avoid redundancy. Alternatively, each card has its own label which a screen reader might read if they swipe through, but it might be better to have one consolidated readout for efficiency. We likely implement an aria-live region elsewhere (like a status log) that announces “Flop: Ace of Hearts, 7 of Clubs, 7 of Spades” at the moment of dealing. But as a baseline, we’ll ensure static labels: e.g. container has aria-label="Board cards: A♥, 7♣, 7♠" which updates when cards update.
Edge cases: If fewer than 5 players (not applicable in our locked 6-max v1), sometimes one deals burn cards or different game types – not relevant here, we specifically do Hold’em 5 community max. If the round ends early (e.g. everyone folded before river), some community cards won’t be dealt; that’s fine, the component will just remain with 3 or 4 cards. If a showdown requires revealing remaining deck (rare, not in hold’em), we wouldn’t implement that. So nothing special beyond just showing what’s dealt.
PotDisplay Component (client/src/components/PotDisplay.tsx)
Purpose: Shows the total pot amount in the center of the table UI. Optionally, can show side pots if they exist (for v1, we assume at most one pot).
Props:
amount (number) – The total pot amount (chips or dollars).
(Optional) sidePots (array of numbers) – If there are side pots, could list them. But for simplicity, we handle one pot.
Rendering: Typically a text label like “Pot: 1500” or just the chip amount without label. We will include a chip icon or graphic next to it for clarity. The display should be clearly visible on all backgrounds: likely we use a contrasting text color with a subtle text-shadow for readability on the table. For example, white text with a dark shadow on a green table. Font size ~14px on mobile, up to 16-18px on desktop. We may enclose it in a small rounded pill background if needed (semi-transparent black background) to ensure contrast in light mode. Position: We place the pot display slightly above the exact table center, so that it doesn’t overlap the community cards (which sit just below center typically). For instance, position it at 50% x, 40% y of the table container. Alternatively, directly above the community card row. We can do: position: absolute; top: 45%; left: 50%; transform: translate(-50%, -50%); or adjust top % as needed after seeing card positions. It should remain between the flop and the center of table visually.
Updates: The pot amount updates whenever bets are added or a pot is taken. This can happen multiple times per hand (e.g. each betting round). We ensure the number animates or increments smoothly if possible. A simple approach: when the pot increases, we could briefly highlight it (flash or bump animation). E.g. use Framer Motion to animate the text from a slightly larger size back to normal or a quick fade in. Another nice touch: when bets are collected into the pot, we might animate chip icons moving to the pot and then update the number. If time permits, we’ll implement a chip movement: at the end of a betting round, animate one or multiple chip images from each betting player’s seat into the pot area, then update the potDisplay. Even if we can’t do multiple, one chip flying from the last bettor’s seat to pot can signal the action. This is polish; our plan is to at least do a visual update on the pot text.
Accessibility: The pot amount should be included in announcements or easily read by screen reader. We’ll give the pot element an aria-live="polite" attribute so that updates (the numeric change) are spoken. For example, when pot goes from 100 to 300, screen reader might say “Pot: 300”. This might be spammy if too frequent, but since pot changes only a few times a hand, it’s fine. Alternatively, we don’t mark it live but have the game log handle it. However, a low-vision user might focus on the pot display – we can simply ensure it has a label “Pot: $X”. Possibly include it in the aria-label of community cards group or separate.
Edge cases: If side pots exist (multiple pots when someone is all-in), we would show “Main Pot: X, Side Pot: Y”. Given v1 likely won’t simulate complex side pots heavily, we might not implement multi-line display. If needed, we can stack text like “Pot1: 1000, Pot2: 500” in smaller font. We’ll note this but not implement unless needed.
Props Example: <PotDisplay amount={750} /> simply renders “Pot: 750”. If we had side pots, perhaps <PotDisplay amount={500} sidePots={[250]} /> would show “Pot: 500 (Side: 250)”.
HandStrengthIndicator Component (client/src/components/HandStrengthIndicator.tsx)
Purpose: Shows the player’s current hand strength or odds in the left panel. This helps the user understand how strong their hand is (especially for beginners).
Props: It will need data about the user’s hand and possibly the community cards. Perhaps the game logic provides:
strengthLabel (string) – A text label like “Pair of Aces” or “Flush Draw”.
strengthValue (number or string) – e.g. a percentage chance to win or rank out of 7462 (poker hand rankings). It could also be a score or category. For v1, perhaps a simple descriptor.
winOdds (number) – If we calculate win probability vs random opponents (this requires simulation, maybe out of scope for v1). Possibly provided if available.
If not implementing odds calc, we might just display the best hand category the player can make with current cards (like what PokerStars hand strength meter does).
We may derive this in client from known data: e.g. if the user’s two cards plus community are known, we can rank the hand. Implementing a poker hand evaluator might be needed. But that might already exist in backend and can be passed. If not, we might simplify: just list the current made hand (like “High Card”, “Pair”, “Two Pair”, etc.) and maybe potential draws (“Open straight draw”) if applicable. Given time, we can at least do made hand rank: that’s straightforward.
Rendering: The component will likely show text like “Hand: Pair of Queens (Best 5: QQ842)” or a simpler “You have: One Pair (Queens)”. Underneath, it could show something like “Possible: Flush draw” or “Win odds: 35%” if we have it. We could also visualize strength – e.g. a bar or gauge that fills as hand gets stronger. Some apps have a meter that goes from weak to strong. If implementing a meter: e.g. scale 0-100, a colored bar (red = weak high-card up to green = strong made hand). We can map hand rank to a percentage (roughly, Royal Flush =100, High card =0). We’ll include a progress bar to make it visual: using Tailwind’s progress or a custom div with width%. Also numeric “Strength: 7/10” maybe. But to keep it simple: start with textual info. Layout in panel: Possibly a heading “Hand Strength” then the content. Could list:
Current Best Hand: e.g. “One Pair (Aces)”
Draws: e.g. “Flush draw” or “No draw”
Equity: e.g. “Winning chance ~ 35%” (if known)
We’ll format nicely. We will scroll if content overflows the panel height.
Interaction: The panel can be toggled open/closed (handled by container layout). Inside the panel, the content is static info. No interactive controls unless we add a “More info” button (not in v1 scope). So it’s mostly read-only. Thus, it doesn’t require focus except if user tabs through, they might land on panel close button if one exists. We’ll ensure proper keyboard navigation to close (Esc or toggling the same button).
Accessibility: The panel should be accessible when open. It should receive focus if opened as an overlay (we might focus the panel or the first element in it). The info inside is textual, so screen readers will read it naturally. If we use a progress bar for strength, use ARIA role="progressbar" with aria-valuenow and aria-label describing e.g. “Hand strength 70%”. All text will be in normal DOM text as well. The toggle button that opens it will have aria-expanded and aria-controls to link to this panel for screen readers, so they know the state.
Performance: Calculating odds in real-time can be heavy (Monte Carlo sim). If not already provided, we will not attempt deep calculation on every tick – maybe just rank the hand, which is quick. So no performance concern.
Edge Cases: Pre-flop (no community), the panel might say “No hand yet – High Card Ace” or such if you have e.g. A♣K♦ preflop. Or we might display something like “Starting hand: [category]” (e.g. “Strong starting hand” or “Suited Connector” etc.). If we have a known table for starting hand strength, could show percentile. That’s a nice feature but likely beyond scope. We can simply show the two hole cards and maybe classification (“Pocket Pair”, “Off-suit”). For v1, maybe just display “Pre-flop – waiting for flop”. If the panel is open when hand ends, it could show the final hand (“Result: Full House – Won”). But that overlaps with history panel’s job. Possibly out of scope – the panel might just freeze at final values until next hand resets it.
FloatingActionMenu Component (client/src/components/FloatingActionMenu.tsx)
Purpose: A collapsible menu button that houses secondary actions on mobile. It allows access to hand strength, history, settings, etc., without cluttering the main UI.
Props:
actions (array of action items) – Each item may have: icon (element or src), label (string, e.g. "Stats"), and onClick handler.
Could also have a open boolean controlled by parent, but likely the component manages its own open state internally (toggle on tap).
Rendering: When closed, it shows a single floating button (for example, a circular button with an “menu” icon or a plus “＋”). When opened, it expands to show a cluster of 2-3 smaller buttons above or around it. We might implement the expansion vertically upwards: the main button at bottom (near bottom-right corner above action bar), and when tapped, two buttons pop out above it (stacked vertically with some gap). The first might be “Hand” (left panel) and second “History” (right panel). Possibly a third “Settings” if needed (toggle sound/theme). The items can be represented by icons only to save space, with tooltips or accessible labels. For instance: a poker hand icon for HandStrength, a clock/notepad icon for History, a gear for settings. We will supply aria-label on each for SR. The floating menu background should contrast (maybe use the same style as action buttons or a slightly translucent black if over table). The menu uses Framer Motion or simple CSS transition for the expansion: tapping the main button sets state open=true which then renders the item buttons with a motion (translate and fade from the main button’s position). We also likely rotate the main button’s icon (e.g. plus becomes × or an arrow rotates) to indicate close. The expanded state might dim the background slightly or not – since it’s small, maybe not needed. We will auto-close it if user taps outside or on one action.
Interactions:
Tap main button: toggles open/closed.
Tap action button: triggers that action’s handler, then menu closes. e.g. tapping the “Hand” icon will call a prop like onHandClick() which opens the HandStrength bottom sheet or panel.
If the FloatingActionMenu is open and the user presses ESC (on desktop), we should close it (for accessibility). Also clicking outside should close it (we can handle via a document listener or an overlay div).
The menu appears only on small screens by design (we’ll render it conditionally: lg:hidden so it’s not on desktop). On desktop, those actions might be directly visible or not needed (hand panel is persistent, etc., and settings could be a normal menu).
Accessibility: The main button is a toggle – give it aria-expanded and aria-haspopup="menu". The expanded list of buttons can be treated as a menu: possibly wrap them in a <ul role="menu"> with each button as a <li role="menuitem">. However, since they’re simply shortcuts, a simpler approach is just a group of buttons. We will ensure proper labeling on each. Focus: when the user tabs to the main button and presses Enter, it expands – we then should allow Tab to move into the popped-out buttons. We may manage focus by moving it to the first action button on expand (or rely on natural order if they come after in DOM). We must also ensure that when open, these items are in tab order; when closed, they should not be focusable (we can remove them from DOM or set display: none).
Visual feedback: highlight the focused mini-button with focus-ring as usual.
The icons should have aria-label attributes since they might not have text. Example: <button aria-label="Show Hand Stats" ...><StatsIcon/></button>.
We’ll also handle closing via keyboard: pressing Esc when open will collapse the menu (set open=false).
Example: If actions=[{ icon: ChartIcon, label: "Stats", onClick: openHandSheet }, { icon: ListIcon, label: "History", onClick: openHistorySheet }, { icon: GearIcon, label: "Settings", onClick: openSettings }], the FloatingActionMenu when open will show three vertically stacked small round buttons with those icons.
Animations: Use a spring or ease-out for the expansion of each item. Possibly stagger: first button appears then 50ms later second, etc., for a cascading feel. Use transform scale/translate from the main button position. Framer Motion AnimatePresence can do this nicely. These animations should be quick (~0.2s) and not block user interaction.
Styling: Buttons likely 50px diameter for main, 40px for mini actions. Use consistent colors (maybe the same accent color as other controls to stand out, or a neutral dark background if over bright table). Could use a slight shadow to stand out. They should not conflict with the action bar (place it slightly above the action bar height or to the side). We'll position it bottom-right with margin ~16px from edges (plus safe-area). On phones with notch, safe-area bottom is added, which pushes it above the home indicator appropriately.
Performance: Not heavy – just a couple extra buttons. Off when not needed.
MobileBottomSheet Component (client/src/components/MobileBottomSheet.tsx)
Purpose: Presents content in a draggable panel from the bottom, covering most of the screen, for mobile screens. We will use this to show either the HandStrengthIndicator or History on phones, since side panels are hidden.
Props:
visible (boolean) – whether the sheet is open.
onClose (function) – callback to close (if user swipes down or taps backdrop).
title (string, optional) – Title to display at top of sheet (e.g. "Hand Statistics").
children (ReactNode) – the content of the sheet (we will pass in HandStrengthIndicator component or a History component).
Possibly initialHeight or snapPoints – not needed v1; we can open to full content height by default.
Rendering: The sheet is a div that slides up from bottom. It typically has a small header bar or handle to indicate drag, and contains the provided content. We’ll likely overlay a translucent backdrop behind it (semi-transparent black that covers the game view) to focus attention. On open, we render the backdrop and sheet; on close, remove them (with animation). The sheet itself will be styled with a rounded top corners (e.g. rounded-t-2xl), a thicker top bar (maybe a 40px tall area with a centered short grey bar as a drag handle). We display the title centered in header if provided. The rest is scrollable content (especially for history list). We might use Radix Dialog under the hood for accessibility, but a simple custom is fine for now.
Interaction:
Open: Triggered by some external action (FloatingActionMenu or toggle). When visible becomes true, we mount the sheet. It animates from transform translateY(100%) (off-screen bottom) to translateY(0) (on-screen) over ~0.3s ease-out.
Close: User can close by:
Swiping down on the sheet – we implement touch event on the header (drag down to close if beyond threshold ~50px or fast swipe).
Tapping outside (on the semi-transparent backdrop). The backdrop onClick will call onClose.
Tapping a close “X” button if we include one in the header. Might include for clarity. This “X” would be in top-right of the sheet.
Pressing Esc (we'll capture key events to call onClose, especially if we treat it like a dialog).
After close, set visible=false and unmount after animation.
Accessibility: We treat this bottom sheet as a modal dialog in accessibility terms:
When opened, we add aria-modal="true" and focus trap the content. The rest of the page (game UI) should be inert to SR and keyboard.
The title prop is used as an aria-label or we render it in a <h2 id="sheetTitle"> inside and add aria-labelledby="sheetTitle" on the sheet container.
If we use role="dialog" on the sheet container, that’s appropriate.
We will ensure focus moves into the sheet on open (e.g. focus the close button or the first focusable element in content). And on close, return focus to the previously focused element (e.g. the FloatingActionMenu button that opened it).
The backdrop gets aria-hidden="true".
Keyboard: Esc closes as mentioned.
Content specifics:
If showing HandStrength: We simply mount that component inside. Possibly style it to have some padding.
If showing History: we could have a list of past hands/actions. Possibly the content is a scrollable list of text or items. The sheet should be sized maybe at 80% height if content is large, else shrink to content. We will allow it to expand to full screen if needed (e.g. if history is long, the sheet can scroll internally).
Styling and Animation: Use transition-transform and maybe transition-opacity for backdrop.
E.g. .sheet { transition: transform 0.3s ease; } .sheet.open { transform: translateY(0); } .sheet.closed { transform: translateY(100%); }.
Actually, we’ll control via JS and apply classes.
For better physics, we might use Framer Motion drag for the swipe-down: making the sheet draggable on y-axis with boundaries. If user drags beyond ~30% and releases, we consider it a close and animate off screen. If they drag and let go below threshold, animate back up.
For v1, if time allows, implement the drag using Framer’s drag="y" and dragConstraints={{ top:0, bottom: 0 }} for a controlled area, with an onDragEnd that checks velocity and offset to decide close or snap back.
If short on time, we can skip robust drag and just rely on tapping X or backdrop.
Example Usage:
<MobileBottomSheet visible={showHistory} title="Hand History" onClose={()=>setShowHistory(false)}>
  <HistoryList ... />
</MobileBottomSheet>
Renders the sheet with "Hand History" title and content.
Performance: Minimal. The presence of backdrop and sheet adds some DOM when open, which is fine. We will ensure will-change: transform on the sheet during drag for smoothness.
Edge Cases: If device has a very tall screen, the sheet might only cover needed content – that’s fine. If user rotates to landscape on phone while sheet open, it should re-center properly (we’ll make sure the position updates via CSS (bottom:0 will always anchor it). Also account for safe-area bottom in sheet padding so content not under home indicator (sheet likely extends to bottom anyway, but we add padding-bottom equal to env(safe-area-inset-bottom)).
If multiple sheets might be opened (should not happen in design – only one at a time), we prevent double open.
This covers the major components. Minor components like individual history list items or the dealer chip icon can be implemented as simple sub-components without complex APIs.
5. Gestures, Haptics, and Sound
We aim for a tactile, immersive experience, borrowing from mobile game best practices:
Swipe & Touch Gestures: We have integrated several intuitive gestures beyond tapping buttons:
Flick up to Fold: The user can flick their hole cards upward to fold
medium.com
. This uses the PlayingCard component’s drag event. The card(s) will animate as if thrown away – we’ll apply a quick upward translation and fade-out when the threshold is passed. On triggering, we call the fold action (with a confirmation sound/vibration). This gesture is only active on the user’s turn (to prevent accidental flicks when not needed). If the user starts a drag on their card, we’ll also highlight a “fold zone” (perhaps the area above, or change card opacity) to indicate the action.
Double Tap to Check/Call: Anywhere on the table (outside actionable UI), a double-tap will trigger a check or call
pokerfuse.com
medium.com
. We will implement a fast double-tap detection (~300ms interval). On detection, if check/call is valid, we instantly perform it. (If it’s not the user’s turn or they can’t call, we ignore the gesture.) For feedback, we might flash the action text on screen (“Check”) to confirm the gesture was received, since there’s no button press visual. Possibly we can momentarily highlight the corresponding button. This gesture allows one-handed quick play.
Swipe right to Call: We will detect a horizontal swipe (left-to-right) in the bottom area as an alternative to double tap for calling. If user swipes the action bar area or anywhere with a significant rightward motion, and it’s their turn with a call available, we treat it as call. (This is somewhat redundant with double tap, but some might prefer swipe). We’ll implement it if feasible by tracking touch move x offset on the ActionControls container.
Hold & Drag to Raise: The user can drag a chip to set a bet amount
pokerfuse.com
. On mobile, pressing the chip stack at their seat and sliding toward the center will initiate a raise. As they drag, we’ll provide visual feedback: e.g. a floating chip stack moving with the finger and maybe a dynamic bet amount label that increases with distance. We divide the distance dragged (from seat position towards pot) by a max distance to compute the bet fraction. For instance, dragging all the way to the pot = 100% of chips (all-in), half way = ~50% of chips. We’ll quantize the amount to big blind units or nearest meaningful value. On release:
If they dropped in the central pot area (above a certain y threshold, or velocity fling forward), we finalize the bet at that amount (or maximum if overshoot).
If they release without crossing threshold, we snap the chip back to the seat (cancel raise).
This gesture will be accompanied by haptic ticks: as the user drags and the amount crosses certain increments (e.g. each 10% of their stack or each big-blind worth), we call selectionChanged() to produce a light tick haptic
core.telegram.org
. This gives a tactile sense of “steps”. If they release and commit, we trigger a stronger confirmation haptic as below.
(Note: If implementing fully is complex, a simplified version: any drag beyond a short distance triggers an all-in, essentially making drag=shove. But the goal is a more granular control. We’ll attempt the granular approach for better UX.)
Edge Swipes for Panels: (Optional) We can allow swiping from screen edges to open side panels on tablets. E.g. a swipe in from left edge (starting off-screen) could open the HandStrength panel. This mimics drawer behavior. Since on mobile we use bottom sheet for that content, left edge swipe might not be used. On iPad, left edge is often OS multitasking trigger, so maybe skip to avoid conflict. We will rely on the toggle button for panel.
Haptic Feedback: Using Telegram’s WebApp API for haptics on supported devices
core.telegram.org
core.telegram.org
 (and falling back to simple navigator.vibrate on others), we add tactile responses to key actions:
Button Press: Any time the user taps a main action button (Fold/Call/Raise/All-in), we fire a light impact haptic (impactOccurred("light")
core.telegram.org
). This provides immediate feedback of the tap.
Positive Outcome: When the user wins a pot or hits a strong hand (e.g. makes a flush on the turn), we trigger a success notification haptic (notificationOccurred("success")
core.telegram.org
). This is a stronger, more celebratory buzz. For example, at showdown if the user’s hand wins, or if a big pot is won, success haptic. Conversely, if the user loses a big pot or busts, we might trigger notificationOccurred("error") for a distinct feel (use sparingly to not feel punitive, perhaps not at all unless an actual error).
All-in: Pushing all-in is a dramatic move – we use a heavy impact haptic (impactOccurred("heavy")) at the moment the All-in action is made (either via button or dragging chips to 100%). This emphasizes the weight of the action.
Card Deal: We provide a slight haptic for dealing cards to the user – e.g. when the user’s hole cards appear or each community card is dealt, a light tick could simulate the card landing. Possibly use impactOccurred("soft") for each card that appears on table. This is subtle and can improve immersion. If dealing multiple at once (flop), we might do one soft tick for the batch or each with a tiny delay (but careful not to buzz too much).
Slider increments: as mentioned, dragging chip slider triggers selectionChanged() haptics for incremental feedback (this is exactly what selectionChanged is for
core.telegram.org
 – small changes like picker scrolls).
Timer warning: If we had an action timer (not explicitly in spec, but if there’s turn time), as it nears zero, a warning haptic could occur (notification "warning"). We’ll note this if timers exist.
We ensure to use these appropriately – not all devices will support all patterns. The Telegram WebApp Haptic functions will gracefully do nothing on non-supported platforms, so it’s fine to call them.
Sound Effects: Audio cues are vital in poker UX. We’ll include a set of short sounds:
Card Dealing Sound: a “swish” or “card flick” sound when cards are dealt
apps.apple.com
. One sound per card or per batch (the flop could play one slightly longer riff, or three in quick succession).
Chip Sound: the clack of chips when bets are placed. We use a short “chip stack” sound whenever chips move to the pot (e.g. when a bet or call occurs). If multiple players bet in a round, we might play it each time, or just one when adding to pot. Also when the pot is awarded to winner, a larger chip raking sound as chips move to that player.
Button click: we might have a gentle click for UI buttons to reinforce that the press was registered (especially if network latency). This could be a generic soft tick. If we think haptic covers it, sound can be subtle or omitted for button press to avoid doubling with haptic.
Alert sounds: e.g. if it’s the user’s turn and maybe they haven’t noticed, a ping or beep could play to alert them (some apps do this after a delay). For v1, if we have a turn timer, we could beep when timer is low. Otherwise, not needed if user is engaged.
Victory sound: When user wins a hand, a brief celebratory sound (like a chip flourish or short upbeat tone) to reward them. Keep it subtle to not annoy in long play.
Fold sound: perhaps a distinct sound for folding (like a flick or a card throw sound).
Check sound: maybe a tap on table audio (some apps use a knock sound for check). We can include a quiet knock.
All-in sound: possibly a specific dramatic sound (some apps do a sweeping all-in sound). We might reuse the chip sound but louder or a combination with a whoosh.
Implementation: we will load these audio files (likely small .mp3 or .wav) and play via HTML Audio API. Ensure Audio can play without user gesture (most modern mobile require user gesture to start audio – since our interactions are user-initiated, it’s fine). We’ll centralize audio in a module so that one audio doesn’t overlap unpleasantly with others. Possibly allow only one chip sound at a time (or mix softly).
Volume & Mute: We will provide a quick way to mute sound (some users in public will want silence). Possibly a small speaker icon in the FloatingActionMenu or as a toggle in settings. For v1, at least an on/off toggle in a Settings panel (if implemented) or we can repurpose the theme toggle for sound if needed. We can default sound on but remember user preference in local storage if toggled off. Haptics we might tie to sound toggle or separate, but those are subtle enough to leave on unless device global settings disable them.
Synchronization: We’ll ensure sound/haptic fires at the correct moments in animations. For example: play dealing sound exactly when card begins moving or when it hits the table – choose what feels better (likely at start of animation is fine). Chip sound when bet action is executed (maybe slightly after the action to simulate chips hitting pot). All-in sound immediately on commit. Use setTimeout relative to animation or hook into animation completion events for precision if needed.
All these tactile enhancements will be tested on actual devices (or at least simulator) to fine-tune intensity and volume. They add feedback and satisfaction, making the game feel responsive and alive.
6. Accessibility Plan
We commit to meeting WCAG 2.1 AA guidelines for the TeleHoldem UI. Key accessibility measures:
Color Contrast: All text and essential UI elements will have sufficient contrast against their background. We target a minimum contrast ratio of 4.5:1 for body text and 3:1 for large text or UI components
webaim.org
. For example, the white text on dark action buttons easily exceeds 4.5:1; if using colored text (e.g. bet amounts in green on dark bg), we’ll test those. We will adjust the theme tokens if any fail: e.g., if our default red on dark background is too dull (contrast < 4.5), we’ll choose a brighter red or use white text on a red button instead. Similarly for dark mode backgrounds, we ensure slightly lighter darks for text readability (e.g. not pure black on pure green). We’ll use Chrome DevTools or WebAIM’s contrast checker to verify each style. This includes iconography: any icon that conveys info (like an icon-only button) will also meet 3:1 contrast against background per WCAG 1.4.11 for non-text items.
Text Size and Zoom: We avoid tiny text. The base font ~16px ensures legibility
zignuts.com
. We also account for iOS/Android accessibility settings: if the user has text scaling enabled, our use of rem units means the text will scale accordingly. We will test at 200% browser zoom and with OS large text settings to ensure UI components do not break. If at extreme sizes some labels overflow their containers (e.g. a very long player name or large font causing overlap), we implement graceful truncation or wrapping:
Player names: limit to, say, 10 characters visible and then ellipsis. Use CSS text-overflow: ellipsis on the name text in PlayerSeat, so at narrow sizes it truncates with “…”. Provide the full name in a title tooltip or accessible name if needed (less important here).
Button labels: If text scaling causes “Check” or “All-in” to overflow button width, the button should expand (since we use flex), up to a max. If screen is too narrow, better the text wrap to two lines than cut off. We’ll allow wrapping on the All-in button if needed (e.g. "All-\nin" on very small device with huge font). It won’t look great but ensures readability. Also our acceptance criteria includes making sure no text is cut off in snapshots at default sizing.
We will test dynamic type on iOS Safari if possible (though web may not pick OS dynamic type easily, user can use pinch zoom or text zoom).
Users can also pinch-zoom the whole interface (unless Telegram container prevents it). We won’t disable zoom. The layout should still be operable if zoomed/panned.
Keyboard Operability: All interactive elements must be reachable and usable via keyboard (for desktop and also for assistive tech like switch control). This includes:
Focus Order: The tab order will follow a logical progression: likely starting at top of page (if any top controls like theme toggle), then through any menu or side-toggle, then into the table action buttons. We need to be mindful that PlayerSeat elements are not focusable (we won't put tabindex on them), so they won't clutter focus order. The typical order when game is waiting: "Start Hand" button (center) would be first (and only) focusable. During play: first focusable might be the Fold button then Call then Raise then All-in (since they are in DOM in that order). This is fine as the primary controls. If on mobile, user likely isn’t using keyboard, but on desktop it should flow left-to-right across the action bar. If we have any always-visible UI like theme toggle (maybe top-right), we should place it logically last or first? Possibly last in DOM so tabbing through the action buttons (center screen) doesn’t then jump to a corner icon unexpectedly. We might put it as the last element (e.g. after action bar in DOM) so that tabbing goes action buttons -> theme toggle. Alternatively, first. We'll choose what feels natural: maybe top nav first, then game controls. However, consider a user who is only using keyboard on desktop: they'd likely want to jump straight to game controls rather than toggling theme inadvertently. Possibly treat theme toggle as part of settings and not in main tab loop. We could give it tabindex="-1" and allow access via a settings menu.
For side panel toggles (if any visible on desktop, e.g. a collapse handle): that should be focusable and logically placed either before or after the main table controls. For example, if a "show stats panel" button is in the bottom left, it might come before Fold in DOM so that Tab from action bar goes Stats (open panel) -> then Fold etc. We will ensure a cycle that makes sense. We'll document any such focus order decisions in code comments too.
Action triggers: Pressing Enter/Space on any focused button triggers it normally (native behavior for <button>). We will add keyboard support for gestures where needed: e.g., Raise slider if open can be adjusted with arrow keys perhaps (if we implement a slider input, it will naturally handle arrow keys). For FloatingActionMenu, pressing Enter on main opens it, then arrow keys or tab can move to sub-buttons. Possibly for a menu-like feel, we might allow arrow-down to jump into the menu, but tab order is fine.
Global shortcuts: We have F, C, R, A keys for quick actions. These are extras and do not replace standard navigation. They will work whenever it’s user’s turn (no need to focus the buttons). We’ll implement them as document keydown listeners that check conditions. We ensure they don’t interfere if focus is in a text field (there are none in game except maybe chat input if that existed, which it doesn’t v1). We'll also ensure that if a modal is open (bottom sheet, etc.), those hotkeys might be disabled to not accidentally fold while browsing history. Likely handle that by not listening when dialog open or when it’s not turn anyway.
Focus management: When modals (bottom sheet panels, etc.) open, we move focus inside and trap it:
For example, when HandStrength sheet opens on mobile, focus goes to maybe the close button in the sheet. We add inert to underlying elements or use aria-modal and JS trap to ensure tab doesn’t escape.
When sheet closes, focus returns to the element that opened it (the floating menu or toggle button). We can store the last focused element and .focus() it on close.
Same for the FloatingActionMenu: it’s small enough not a “modal”, but when user opens it, they might hit Tab: we should loop focus within the expanded items and back to main if continued (like a popover). We can implement a simple loop by making the last action button’s onKeyDown trap Tab and wrap to main button if needed, or simpler, since it’s small, maybe not worry if closing on outside click. But for completeness, we handle focus ring moving to each mini-button on Tab, and if they tab further, either close menu and go next in overall DOM or wrap. Perhaps easiest: treat the open menu as a transient state: if they tab beyond last item, just close it and resume normal tab flow (so they effectively skip to whatever was next after main button in DOM). This might be surprising though. Alternatively, loop inside until closed by pressing main or Esc. We'll likely try to close on any blur/outside focus as well to be safe.
We will test keyboard usage thoroughly: the user should be able to play a whole hand with keyboard: e.g. press "Start Hand" (Enter), then when it’s turn, either press shortcuts or tab to Fold/Call etc. and press Enter. If a sheet is open, they can Esc out. Everything should be reachable.
Screen Reader Labels: We provide accessible names and roles for non-text UI:
Buttons: Use clear text or aria-label. For example, the Fold/Call buttons have visible text which is fine. The FloatingActionMenu mini-buttons are icon-only, so each gets an aria-label (e.g. "Show Hand Stats", "Show History", "Toggle Sound"). The main floating button could be labeled "More options" or "Menu".
Panels: The HandStrength panel as a sidebar should have an accessible name (like a heading "Hand Strength"). Since it’s persistent on desktop, it might be okay without a special role, but giving it a landmark or section label can help SR users navigate. Possibly wrap it in <aside aria-label="Hand strength information"> to indicate it’s complementary info. The history panel similarly could be an <aside aria-label="History and stats">. This way, screen reader users can use rotor/landmarks to jump to these side sections.
Live Regions: Key game events will be announced. Instead of relying on the user to find out manually, we use ARIA live for:
Action Feedback: When the user (or another player) performs an action, a short text is presented in a log or toast. We set that container to aria-live="polite". For example, a toast that says "Alice folds" will be read out. Or "You bet 500". We need to ensure the text is meaningful because the SR user isn't seeing visuals. Possibly we maintain a hidden log of actions (e.g. an offscreen <div aria-live> where we append "You called. Pot is now 1500."). This keeps them informed of game progress. The spec did mention toasts with aria-live.
Turn Notifications: When it becomes the user's turn, we will announce it. Perhaps something like aria-live="assertive" to say "Your turn" because that’s time-sensitive. We can trigger this via the game state change (e.g. focus the action bar or just set a live region text).
We must be careful not to overload announcements. Polite for routine actions, assertive only for urgent like "Your turn, 10 seconds remaining".
The pot display and community cards updates: we can also announce these changes politely (e.g. "Pot: 1500" when it grows, as earlier we considered making PotDisplay aria-live).
Alternatively, a better approach is a unified log: "Bob bet 200. Pot 600. (your turn)". We might implement a hidden log region that collects such sentences. A screen reader user could also review this log by focusing it (if we allow).
We'll keep toasts visible to sighted users as well (like small text at top). Those toasts (like "Player X wins the pot") can double as live region announcements by adding role="alert" or aria-live.
Image alts:
Card faces: we label them with suit and rank for SR. If we already announced the flop as a whole, we might mark individual card images aria-hidden=true to avoid redundancy. Alternatively, no harm if each card is read, but likely better to have a single summary. We'll implement the summary on container and hide the individual card elements from SR.
Avatars: If using user profile pictures, those would have alt="", because the name is already text next to it. If avatar is decorative just hide it from SR.
Icons: All icons on buttons have no text, so they need aria-label on the button (or title attributes) to convey meaning. We'll rely on aria-label as mentioned.
Focus Visibility: We will style focus outlines clearly. Using Tailwind, we’ll add focus-visible:ring etc. The default focus ring might not be very visible on a complex background, so we tune it:
On dark backgrounds, we can use a bright outline (e.g. 2px cyan or white outline offset).
On light backgrounds, maybe a dark outline or brand color if it stands out.
For example, if a button is focused, often browsers default to an orange or blue outline (which might be fine). But we want consistency across browsers.
We'll implement as: focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-white on dark surfaces, and maybe focus-visible:ring-dark on light.
We will test by keyboard-tabbing through. Particularly, the action bar likely has a dark semi-transparent bg; a focus ring of a contrasting color around buttons will be visible. For side panel toggles on dark table background, maybe use a white or yellow ring.
We ensure the focus indicator meets the new WCAG 2.2 criteria (if we aim for AAA or future proof): at least a 3:1 contrast difference with adjacent colors
ux.stackexchange.com
. So if our focus ring is 2px white on black background, that’s high contrast, good. If focus ring is light on a light background, we need an offset or shadow. We did plan an offset (focus-visible:ring-offset-2 with an appropriate offset background color) to ensure it’s distinct.
We also ensure no element hides the focus ring (no outline:none without replacement). Except when using focus-visible to avoid showing focus on mouse click which is okay.
Content Structure & Navigation:
We use appropriate semantic elements for structure: e.g. use headings in the HandStrength panel text content so SR users can skim. Use lists for listing actions or players if needed. The main table might be represented conceptually as a region but not necessarily a table structure (players in seats isn't a tabular data per se).
We'll identify if any element should be given a special role/landmark:
The action bar could be a nav landmark labeled "Actions" maybe, but since it's basically form controls for the game, leaving it as a <div> with buttons is fine.
The entire game area might be a <main> landmark since it's the main content of the page. Actually yes, we likely wrap the game interface in <main role="main"> so screen reader knows this is the main app content.
Side panels could be <aside> as mentioned.
A toast region at top might be <section aria-label="Game updates" aria-live="polite">.
We'll ensure heading levels are logical if any (like Hand Strength panel might have an <h2>, and inside it maybe <h3> for "Current hand: Pair of Aces").
ARIA for game status:
Possibly we can use role="status" for some text that shows game state (like "Waiting for next hand"). Role status is like polite live region by default. For example, when a hand ends, and we wait, we could have a status line "Hand over. Waiting to start next hand." It will be read once.
If the user busts or game ends, we'd convey that (maybe "Game over, you are out of chips." in an alert).
We must announce if the user wins or loses a hand: the result. That can be done via the toast or an alert. E.g., after showdown, a toast "You win 1500 chips" with role="alert" so it's announced assertively.
Testing A11y: We will use tools like axe DevTools and manual SR testing (VoiceOver and NVDA) to catch any issues:
Ensure no element gets keyboard focus that shouldn't (like hidden elements or decorative icons).
Ensure each interactive element has an accessible name (axe will flag if not).
Ensure color contrast warnings are all resolved (axe will flag sub-4.5:1).
We will navigate using only keyboard and with VoiceOver to simulate the experience. We'll verify that the SR reading order is logical and that no critical info is missed. For example, does VO announce the community cards properly? If not, we adjust labeling.
With these measures, the game should be playable and understandable for users with visual or motor impairments. Some advanced aspects (like a blind user fully playing might require them to rely on announcements heavily; we hope our live commentary covers enough). We also consider hearing impairment – all essential info is conveyed visually as well (sounds are supplemental). For cognitive disabilities, we try to maintain clarity in text and not use overly confusing jargon (we label things clearly and provide consistent locations for information).
7. Performance and Animations Budget
We target a buttery-smooth 60 FPS experience
core.telegram.org
 on modern devices. To achieve this, we set a performance budget and use efficient animation techniques:
Frame Budget: At 60fps, we have ~16.7ms per frame for all work. Our goal is to keep animation and rendering within ~8ms typically, leaving headroom for input events and logic. We must avoid jank during critical animations (dealing cards, chip movements). We will test on a mid-range device (e.g. an older phone or CPU-throttled desktop) to ensure even under load we maintain at least ~40-60fps for animations (some minor drops might occur on heavy action but aim to minimize).
Limit Concurrent Animations: We will not animate too many elements simultaneously. Specifically:
Card dealing: ideally one card moving at a time (or at most 2 with slight overlap). We will stagger animations rather than do all at once.
Chip movements: if multiple chip stacks need to move to pot at once (side pot scenario), we can sequence them or group them into one animation. Typically, bets are collected one by one or nearly simultaneously. If it's simultaneous, it's usually only a couple at the same time – that should be okay, but we ensure those animations are simple (translation) and not more than say 3 elements at once.
Continuous pulses (like seat highlight): These count as animations running constantly. We keep such effects lightweight (CSS opacity or box-shadow transitions on a small element). We also prefer to only animate the outline or a drop shadow rather than a large glow that repaints huge area. We might restrict pulsing to opacity or use CSS filters if performant. We verify it doesn't noticeably affect frame rate (it shouldn't, but if it did, we could reduce the frequency or only pulse a couple times then pause).
We will avoid CSS animations on large background properties or anything that triggers layout on each frame.
Transform & Opacity Only: We adhere to best practice: animate transform and opacity properties only for moving/fading elements. No animating width/height, top/left (which cause reflow) or expensive box-shadows on large elements.
All our planned animations (card movement, chip movement, flips) use CSS transform: translate/rotate/scale which can be GPU-accelerated.
We will set will-change: transform on elements that will animate to hint to browser. But careful: we won't leave too many will-change set permanently (memory use). Possibly add it right before animation via classes and remove after, or rely on Framer Motion which handles some of this.
For opacity fades (toasts, backdrop), those are fine to animate (no layout changes).
We avoid animating box-shadow radius/growth continuously (that triggers paint of area). If we do a gentle glow pulse, it's likely fine but we'll monitor. Alternatively, simulate glow by animating an outward scale of a semi-transparent ring element behind the avatar (which is transform).
We do not animate border properties or fonts or anything heavy.
Use of Framer Motion: Framer is known to use requestAnimationFrame and batch updates efficiently. However, it does add some overhead. We will use it selectively for complex sequences (like orchestrating drag and drop, spring physics for bounce). For very simple animations (fade in/out of a static element), CSS transitions might suffice and have lower overhead. We'll balance: e.g. for card dealing, we may just apply CSS transition to a card component’s position if we know final coords. But since final coords might not be known without layout measure, using Framer's layout animation could be simpler. We must watch out for layout thrash: if we use Framer's AnimatePresence to mount/unmount elements, it will measure things. With only a few elements, should be fine.
Max concurrent Framer animations: We might have e.g. 3 card flips at once, plus a chip moving. That's not too many. But we should try to keep simultaneous animations < 5. If we find ourselves wanting to animate 10 things at once (like 6 player cards dealing simultaneously), better to do sequentially.
We will keep component re-renders minimal during animations. Ideally, animating via transform doesn't trigger React reconciling in the middle of it. If using Framer Motion components, it handles via internal state. It's okay.
Asset Strategy (Images/Vectors):
We’ll use SVG or icon fonts for simple graphics (suits, small icons) to scale well and render fast. For card faces, an SVG might be fine or just using text+CSS for the letters. That avoids loading 52 images.
If we use any PNGs (like for card back or chips), ensure they are small and perhaps sprite-sheeted if multiple states, to reduce network requests. But likely one card back image and one chip image, that’s fine.
We should preload critical images (card assets) so first use doesn’t stall. e.g. include card back image in the initial load or prefetch it on waiting screen.
Use appropriate resolution: no super high-res images that we then scale down. A card back ~100x140 px might suffice for mobile; we can have a 2x for retina maybe 200x280. Keep file size low (under 20KB).
Use modern formats (PNG or SVG for flat graphics; possibly WebP if photo-like but we don't have those).
The table background might be a simple CSS radial gradient (cheap to render) rather than a large image, for performance and theme flexibility.
Memory & GC:
We keep long-lived objects minimal. For example, not storing huge arrays in state unnecessarily. The largest data might be a history log, but that likely small text.
Framer Motion animations might allocate objects per animation. It's fine, but we ensure to properly unmount components not needed (like toasts) so memory is freed.
The game likely doesn't create tons of new DOM nodes beyond some ephemeral toasts or animations, so memory leak risk is low.
We will monitor using performance devtools if any event listeners or intervals might cause CPU usage (e.g. if we had a game loop or timer tick – we'd use requestAnimationFrame or setInterval? But likely none needed beyond maybe countdown which can be a CSS animation if needed).
Optimize Idle and Background:
If the game is not in focus or tab not visible, we could pause animations (e.g. stop pulsing glow to save battery). It's minor, but we can heed prefers-reduced-motion (if set, we disable non-essential animations by design).
If user is idle, not much happens anyway. If in waiting state, nothing animating except maybe a subtle table background? (We might have none).
We won't implement heavy continuous animations (like confetti or particle effects) to avoid background CPU.
Prefer CSS Animations for simple tasks: They run off main thread (for transforms, using compositing), reducing JS overhead. We'll use CSS for toast fade-out etc. Framer can also be fine.
Reduced Motion:
Honor prefers-reduced-motion: reduce media query
core.telegram.org
. If user enabled it, we'll drastically minimize animations:
Skip non-essential ones (card dealing can simply appear instantly, or much faster).
Turn off seat glow pulse (maybe just a static highlight border).
Still keep necessary feedback but possibly in simpler form (like a quick flash vs smooth animation).
We can implement by wrapping motion usage: e.g. Framer has reduceMotion config, or do conditional durations (set to 0 if reduce). We'll implement checks and possibly add a CSS class like .reduce-motion .animated-element { transition: none !important; } globally when detected, to override any existing animation classes.
We also ensure no auto-playing animations that could distract those users. Our game doesn’t have decorative video, so fine.
Guardrails for Framer Motion usage:
Use motion.div on elements that need it, not on large containers with many children unless needed. That avoids overhead of monitoring lots of subtrees.
Avoid using layout animation on big lists (we don't have big lists).
Turn off features we don't need: e.g. whileTap effects can be done with CSS instead of Framer if simpler.
Unmount Framer components when done to not keep listeners alive.
Use dragConstraints properly to prevent layout thrash when dragging.
Use transition={{ type: "spring", ... }} settings that are not too bouncy or long, to end animations quickly (0.3–0.5s mostly).
We'll measure using the performance timeline if any dropped frames and pinpoint them.
Profiling Steps:
Use Chrome Performance or Safari Timeline while performing heavy sequences (deal flop, all players bet, etc.) to see if scripting or painting spikes beyond 16ms.
Look at "Major Rendering" issues: e.g. if animating a property triggers layout repeatedly (shouldn't if we do transforms correctly).
Use React DevTools Profiler to ensure no unnecessary re-renders during animations (maybe freeze during animations by not updating state extraneously).
Check memory in devtools for any buildup if we repeat actions (to catch leaks).
We'll also test on a mid-tier Android phone which often is less powerful, to catch any jank.
FPS Monitoring: We might integrate stats.js or simply rely on devtools. Possibly enabling the FPS meter in Chrome can give a visual. We'll ensure typical actions keep FPS ~60. If any drop e.g. during multi animations, we consider simplification.
In summary, by limiting concurrent animations, using GPU-accelerated CSS transforms, respecting reduced-motion, and profiling on real devices, we ensure the UI is smooth as per modern app standards
core.telegram.org
. If anything is found to cause jank (e.g. an overly elaborate effect), we’ll cut it or find a cheaper method.
8. QA Strategy (Authoritative & Exhaustive)
To guarantee a high-quality release, we will perform comprehensive QA across devices, layouts, and scenarios. Our QA strategy includes: Device & Browser Matrix: We will test on at least the following:
Mobile iOS: iPhone SE (2nd gen, 4.7" 375×667pt @2x), iPhone 12 or 13 (6.1" ~390×844pt @3x) in both portrait and landscape, iPhone 14 Pro (because of dynamic island, though UI mostly unaffected, but check safe areas).
Mobile Android: a small Android (e.g. Pixel 3a ~393×740dp) and a larger one (~411×891dp) to cover common sizes. Test Chrome for Android.
Tablet: iPad (768×1024px) in portrait and landscape. This ensures our md and lg breakpoints. Possibly an iPad Pro (1024×1366) for a bit larger but same breakpoints apply. Test Safari or Chrome on iPad.
Desktop: Windows 10/11 Chrome at 1280×800 (simulate our base desktop breakpoint, also ensure no horizontal scroll at that size). Also test a larger window like 1440×900 or 1920×1080 to see how UI centers and if any max-width needed. Additionally, test Firefox and Safari desktop to catch any browser-specific issues (especially with CSS env safe-area and such).
Telegram In-App Browser: If possible, test within Telegram (both iOS and Android) because it might have quirks. If not, at least test in mobile Safari which should be similar to Telegram webview on iOS, and Chrome WebView for Android.
Testing Phases and Cases:
Layout & Safe Area Checks:
Open the game on devices with notches (e.g. iPhone 12 with notch) and verify: no content is obscured by the notch or corners. Specifically, ensure:
The action bar has appropriate bottom padding so that on iPhone X/11/12/… the home indicator does not overlap the fold/call buttons. We visually inspect (the distance from bottom of screen to buttons should equal the safe-area inset ~34px on X). If using snapshots: e.g. check iPhone12_dark.png that the action bar background indeed extends below the buttons to the screen bottom, leaving an empty cushion area.
On iPad or Pixel with no notch, ensure we didn’t add unnecessary blank space (the safe-area insets should be zero and padding not noticeable).
Top safe area: If any UI is near the top (like perhaps the floating menu might be near top if expanded? Or toasts at top), ensure they aren’t under the status bar or cut off. We trigger a toast (e.g. simulate a "Player X wins" toast) and see it appears fully below any status bar on iOS.
In landscape on iPhone (if we support it), safe-area on left/right might apply. Make sure side panels or table doesn’t get cut by rounded corners. E.g., on iPhone in landscape, safe-area insets ~21px on each side – if a player seat is at extreme edge, it might fall under that if we didn’t pad the container. So check in landscape that seats aren’t hugging the very edges.
Orientation changes: On iPad, rotate from portrait to landscape and vice versa. Confirm the layout transitions correctly (left panel appears/disappears as per breakpoints, nothing overlapping). Also ensure no weird resizing issues (like table container aspect re-evaluates properly). This might require a page refresh ordinarily, but we should be responsive without reload. We manually verify by resizing browser window as well.
No Horizontal Scroll: At any supported resolution, the page should not scroll horizontally. We check in devtools at breakpoints (320px up to say 1280px) that no horizontal scrollbar appears. If one does, inspect what element is causing overflow (maybe a fixed width or a transform issue). We fix it.
No vertical overflow (except perhaps on very short screens or when bottom sheet open): Typically, the game is one screen tall. We verify that on devices like iPhone SE (short) in landscape maybe, do we cause vertical scroll (if table aspect tries to be tall)?
Use snapshots or visual inspect at 320x568. Ideally, the whole UI fits within the viewport with maybe action bar pinned to bottom. If any part is cut off or scrolls, consider adjusting max heights. It's acceptable if on very short screens like iPhone 5 the top of table is a bit cut, but we aim to avoid that via aspect ratio handling.
Breakpoints trigger correctly:
Use Chrome responsive emulator or manually resize: at width 767px, verify that the UI is still in "mobile mode" (no side panels visible, FloatingActionMenu visible). At exactly 768px, the HandStrength panel toggle is now available (maybe a toggle button appears). We test clicking it: the panel overlays as expected.
At >=1024px, confirm the right history panel is now visible as a sidebar and content is arranged in 3 columns. Check that the table resized to accommodate and still looks good (not squished too small, not overlapping side content).
Ensure at 1024px we actually see both side panels (if left is default open too). If left is closed by default, ensure toggling it works. Possibly in QA we’ll decide left should auto-open at 1024. We'll confirm what we implemented and test that scenario.
Check the defined aspect ratios: e.g. at 480px width, measure the table element's height (via devtools or a screenshot). It should be ~width/1.85. We'll accept slight rounding differences. At 400px (which is <480), it should be ~width/1.9. On iPhone 12 (390pt ~ 1170px CSS pixels width in screenshot possibly, but treat points for design?), either way ensure the table looks proportionally correct (not too tall or short). On iPad portrait (768 width), table should be using 1.5 ratio. Actually, 768≥md but <lg, our rule said 1.5 ratio for >=768, yes. So measure height ~768/1.5=512px if container fully used width. Check actual.
Also verify max-height kicks in: on a desktop window 1280×800, if our table tries to be 1280/1.5 =853 tall which would overflow the 800 height, we set max-h:80vh (0.8*800=640px). So the table should actually be capped at 640px tall and thus less than full width (some empty space to right likely). We test that scenario: open at large resolution but short height, ensure we see bottom action bar without scrolling. Possibly use devtools to simulate 1280x800 or just shrink a desktop browser window.
If any ratio or responsive rule misfires (table too large, causing cut-off), we'll note and adjust the CSS accordingly.
Action Controls & Buttons:
Visibility Logic: Test various game states by simulation or by temporary prop manipulation:
When phase='waiting', confirm that only the "Start New Hand" (or equivalent) button is shown and centered. After clicking it (simulate starting), ensure it disappears and action buttons appear.
When it's the player's turn pre-flop with no bet, ensure buttons visible: Fold, Check, Bet, All-in. (Call should not be there because no bet to call).
Simulate a scenario with a bet on table: e.g. set canCheck=false, callAmount=100. Ensure buttons now: Fold, Call 100, Raise, All-in. "Check" is replaced by "Call 100", and "Bet" replaced by "Raise".
If player is out of chips (chips=0 and still in hand logically means all-in): All action buttons should presumably be disabled or hidden (can't do anything). Test scenario: chips=0, should we hide them or disable? Probably hide fold/call (or disable with reason?). We likely won't get user turn if they're all-in. But if we want to cover it: ensure that at all-in state, maybe only All-in button is disabled or nothing shows since they can't act. We'll see implementation and test accordingly.
Ensure that impossible combos never appear (like Check and Call at same time, or Bet and Raise at same time).
Disabled state: When it’s NOT the player's turn (e.g. after they act, waiting on others in multi-player), we expect either the buttons are disabled or hidden. Likely we hide them entirely (common pattern is to hide action buttons when it's not your turn). If we implemented disabled, we test that they indeed are greyed out and non-interactive. Possibly easier: when not user's turn, action bar might show a message "Waiting for others..." instead. If we did something like that, verify that message appears.
Test that the "All-in" button is present whenever the player has >0 chips. If some condition could have removed it incorrectly, we check. E.g., at preflop, All-in should be there along with Bet (some UIs hide All-in until maybe slider, but we decided to show it always; we ensure that).
Sizing & Touch Area: On each device or snapshot:
Measure the action buttons to confirm they meet the 48px minimum in both dimensions
ux.stackexchange.com
. Use devtools measurement or eyeball relative to known device resolution. For instance, on iPhone 12 (3x scale), a 48px element would be 16pt tall. We ensure they're at least that. If using snapshots at 100% scale, we can measure in an image editor or by comparing to known interface elements. It's easier with devtools: inspect the button, see its CSS width/height. Should be >=48px.
Also check there's enough spacing between buttons. Should be ~8px gap. On small widths, ensure they are not touching or overlapping.
On narrow screens (320px), do the four buttons still fit? They may be snug but should not overflow beyond screen edges or stack incorrectly. We test iPhone SE (320) scenario: all 4 actions are visible and fully on-screen. If one is cut off, it's a bug. Possibly we might see All-in might be narrower (which is fine if text fits).
Press area: we can test by trying to tap the very edge of a button on a device (if possible) to ensure it's responsive. But since we adhered to 48px and some margin, likely fine. We'll consider adding some invisible padding (touch padding) if needed.
Keyboard Shortcuts: On desktop:
Focus not on any input (just the document body or the game area), press "F". Verify it triggers the fold action (we might log something or see the UI respond, e.g. the player's cards fold or a toast "You folded").
Press "C": if you had a check/call available, ensure it triggers that (for check, maybe see that no chips go in and turn passes; for call, pot increases). If state not easily set, we might simulate by forcing the function or reading console logs if we put one in event handler.
"R": if raise is applicable, in our simplified approach maybe it opens slider or does min-raise. If slider appears, that's the expected result. If we didn't implement slider yet, maybe it just does something minimal. But check that "R" at least is recognized (maybe show a console message if no UI).
"A": triggers all-in. Should cause the All-in action (the chips move or a toast "You are all-in").
Also ensure that these keys do nothing when it’s not the player's turn or when the button would not be present (we don't want an accidental key to fold out of turn or when there's nothing to do). Possibly test by making it not player's turn, pressing keys and confirming no action triggered / no error.
We also ensure the keys are case-insensitive (pressing lowercase f vs uppercase F, probably using event.key). Typically event.key is case-sensitive only for letters? Actually "f" vs "F" might come as the same if not in combination with shift. We'll ensure it catches either by lowercasing the input.
Gesture Testing (touch):
Double-tap: On a mobile device or emulator, attempt to double-tap the table area when check/call is possible. E.g., during your turn with no bet, double-tap on an empty part of screen (not on a button). Expected: the check action triggers (you should see the action happen in game, like turn passes and maybe a toast "You checked"). We may need to coordinate with game logic or at least ensure our event listener fires (maybe log in console).
Swipe up to fold: Press on one of your hole cards and flick upwards quickly ~ a few centimeters. Expected: your cards fold (they might animate off table) and fold action triggers. We'll verify the visual result or console log if any. If implemented, also test a slower drag not reaching threshold: it should snap back and not fold. Check that threshold feels right (not too sensitive or too hard).
Swipe right to call: If implemented, try swiping from left to right across the action bar area. If call is available, it should trigger. We see if our call triggers in UI (chips move to pot or next action).
Drag chip to raise: On mobile, attempt to touch the chip stack on the player's seat (if visible as an element) and drag it toward the center.
See if a floating chip graphic follows your finger (if we implemented visual feedback).
Drag to different distances and release:
short drag release (should cancel or do minimum?),
long drag near center release (should commit raise possibly maximum).
Particularly drag all the way to pot and drop: expected to commit all-in. Check that indeed triggers an all-in (the All-in button outcome). Possibly in UI you'll see you have 0 chips after, etc.
If we have intermediate amounts, try stopping halfway and releasing: does it bet roughly half your stack (if implemented)? We might log the decided amount to verify the mapping.
Try dragging and then dragging back and cancelling (like change mind): ensure if you drag back to origin and release, it cancels gracefully (no action triggered).
Haptic feedback: if device supports (iPhone), see if you feel subtle taps while dragging and a stronger one on drop. If not easily noticeable in quick test, might need more controlled environment or trust code. But we can test at least that calling the haptic API on e.g. Safari actually triggers (maybe a slight bump).
Edge swipe for panel (if any): If we allowed swipe from left edge to open HandStrength on iPad, test swiping in a bit from left; if Telegram intercepts edges might not work, but check in Safari. If not working reliably, it's okay if the toggle button is primary.
Tap targets: Confirm that any icon buttons (like floating menu, close "X" on bottom sheet, dealer chip if we made it clickable?) have sufficient target size. E.g., the floating menu main button ~50px which is fine. The mini actions ~40px which is borderline but probably okay on modern screens (40px = ~10mm at 160dpi, a bit under recommended but if we have margin might effectively be ~48 clickable). We'll physically try to tap them on a phone to ensure they're not too fiddly. If they are, consider increasing to 44 or 48px in CSS.
States/Feedback: Check that pressing and holding a button gives some visual feedback (e.g. it highlights). We should have CSS :active styles via Tailwind by default (if not, we might add e.g. active:bg-darken). Check fold button goes slightly darker on press etc. Focus styles we test in accessibility section.
Turn Management & In-Game UX:
Start a hand and simulate a full round in a controlled environment:
Confirm that when it’s the player's turn, their seat is highlighted (pulsing or glowing border). Check it’s the correct seat (the bottom one for the user). Also if possible simulate turn shifting to next player (maybe by stepping through game in dev tools), see the highlight moves or if only user highlight matters (if we decided only highlight user or always highlight whoever's turn). If multi-user scenario, ensure highlight shows on the correct seat in each phase (if we can't simulate with actual players, maybe fake isCurrentTurn on different PlayerSeat one after another).
Timer (if any visual indicator like a countdown bar or text) – check it appears and animates. We didn't explicitly implement a timer bar but if it was in plan, verify.
Toast messages: e.g. when someone bets or folds, do we show a toast "Bob folds". If implemented, ensure it's positioned nicely (likely above table) and not overlapping UI. If multiple toasts, ensure they queue or each is visible. Check that they disappear after a short time. Also check that they do not trigger when they shouldn't (like no duplicate messages).
End of hand: if we have a "winner" display or chips moving to winner, watch that:
The pot chips animate to winner's seat (if implemented). They should travel smoothly without weird path or clipping.
Winner toast "Alice wins the pot" appears.
Possibly cards reveal: If at showdown, ensure opponents' cards are either shown or at least winner's hand is indicated. If not in scope, skip.
Ensure that after hand, the UI resets properly for next hand (cards cleared, pot reset to 0, "Start Hand" button shows again if applicable).
HandStrength Indicator Panel:
On mobile (<768): open the FloatingActionMenu, tap the Stats/Hand button. Verify the bottom sheet appears with content. Check that content is correct given current cards (e.g. if just dealt preflop, it might say "No hand yet" or show preflop info). If on flop, see if it updates to "Pair of X" etc. This might require hooking into actual game logic – if not easily testable, at least check that the static UI of the panel displays properly and scrolls if needed.
On tablet (md): test toggling the panel via provided button. Panel should slide in from left and overlay part of table. Check that while it's open, user can still see maybe their cards or at least the panel content. Ensure closing works via the toggle or a close control (maybe a swipe out or button).
On desktop (lg): confirm the panel is visible by default (if our design says so). Check the information updates as game progresses (e.g. preflop to flop, does it recalc? If we have logic, otherwise skip dynamic test).
Check panel responsiveness: if text is long (like "Straight Flush draw" etc.), does it wrap properly or overflow panel? Should be in a scroll if needed.
Check color contrast in panel (some text might be colored e.g. percentage in green? Make sure it's readable on panel background).
History/Stats Panel:
On desktop, ensure it’s present at right side. If it lists history events, check they are updated and scrollable if long list.
On mobile, test opening via FloatingActionMenu. See bottom sheet content for history. Scroll through it, ensure it's not cut off.
If no actual history log, maybe it's placeholder text – ensure that looks okay (maybe "History coming soon" etc.).
If any interactive elements in panels (like copy hand history or filter) not in scope, skip.
Animations & Visual Effects:
Card Dealing: Start a new hand and watch the dealing animation:
The hole cards to player: they should move from table center to the player's seat. Ensure they don’t stutter or jump. If both cards dealt sequentially, ensure correct order and spacing (one slightly left, one right in player's area if we do that).
Flop dealing: when flop is dealt, confirm either flip animation or slide works as intended. If we do face-down then flip: ensure they flip simultaneously and reveal the correct faces. Check for any glitch (like card showing backside too long or wrong face).
Turn/river: ensure they appear in correct position and with appropriate animation (flip or slide). Check that the spacing between all 5 community cards is even.
Check performance: dealing animations should be smooth (we can monitor any frame drop visually - e.g. it shouldn't appear choppy). If we notice a jank (card pause mid-way), we may need to adjust code.
Card Flip: Focus on flip effect:
Are cards flipping around vertical axis without weird distortion (maybe we need preserve-3d). Check that the back side isn’t visible at wrong times.
Ensure that text on card isn't mirrored during flip (shouldn’t if done right).
Evaluate if the flip speed looks good (fast enough to not delay game, but slow enough to notice the effect).
Chip Movement: Place a bet in game (maybe simulate by pressing Bet or All-in):
If we animate chips: see a chip or stack image move from player to pot location. It should travel along a curved or straight path smoothly (not teleport).
Check the chip landing maybe triggers a chip clink sound and maybe a slight bounce if we did any effect.
Check multi-bet scenario: if two players bet sequentially, do chips accumulate? If multiple chip animations happen back-to-back, ensure they don't conflict (like one starting before previous finished might cause overlap in pot area, but that might be okay).
If all-in (big chunk of chips): maybe we had a special animation (like multiple chips or a bigger chip icon). Did that display properly? If not implemented, skip.
At showdown, if winner collects pot: see if we animate pot chips to winner. If yes, watch that path and confirm chips end at winner seat and then maybe disappear. Ensure it doesn't leave ghost images.
Seat Highlight: When it's user’s turn, is the pulsing glow noticeable? It should catch the eye but not be obnoxiously bright. Also, verify it's not causing layout shift (it shouldn't if absolute or pseudo element).
If we use a CSS animation, verify it's smooth. Possibly check on a low-end device if the pulse (especially if it's a heavy box-shadow) affects performance. If we suspect it might, consider turning it off and see if performance improves.
Transitions: When toggling panels or bottom sheets, observe the transition:
Opening HandStrength panel (md) slides nicely from left with no jitter.
Opening bottom sheet: content should animate up, backdrop fades in behind. Check no sudden jump in content positioning.
Closing them via swipe or button should animate out smoothly (sheet slides down fully, then is removed).
Check that quick re-open/close doesn't break (like if you tap toggle twice fast).
Motion Reduction Test: Enable "Reduce Motion" in OS (iOS Settings > Accessibility > Motion, or in MacOS accessibility, or use devtools emulation). Reload the app with that setting:
Verify that major animations are either disabled or significantly simplified:
Perhaps cards just appear without flying.
Flips maybe just show instantly.
Seat highlight possibly static border rather than pulsing.
If we implemented detection properly, test that it's indeed picking it up: Could put a console log when applying reduced settings.
Check that no weird visual is caused by skipping animations (like if we skip a transform, ensure final state is correct).
Performance Under Load: Using devtools Performance, record during a heavy sequence (deal flop + several chip moves).
Check the FPS graph if available, ensure frames mostly at 60 (maybe minor dips to 50 are okay, but no prolonged 30fps sections).
See main thread timeline: are any "Layout" or "Recalculate Style" events taking too long ( > 10ms)? If a particular animation causing lots of layout thrash (maybe not likely if we did transforms).
Check memory usage timeline if possible to see no big leaks (though in short time might not show).
If any obvious problem (e.g. a function blocking main thread), identify and plan fix.
Accessibility Verification:
Run an automated accessibility scan (Axe or Lighthouse):
Fix any reported issues like missing alt text, insufficient contrast, missing ARIA labels.
Screen Reader (VoiceOver on iPhone):
Navigate the interface sequentially (swipe right through elements):
It should announce things like "Fold button", "Call 100 button", etc. Are the labels correct and informative? (e.g. hopefully "Call 100" not just "Call button" without the amount – we want the amount included if possible in label).
When it hits a PlayerSeat, ideally it should read our aria-label like "Player Alice, 1500 chips, folded". Check that it does and it's understandable. If we find it's not reading or reading something weird (like reading background image filename), we adjust attributes (maybe needed to add role="group" etc.).
Check that the HandStrength panel content is accessible: if it has text, voiceover will read it if focused. Possibly wrap it in a container with role="region" and label so a user can jump to it.
If a live region announcement happens (like when actions occur):
We simulate a scenario: on user's turn maybe a live region says "Your turn." VoiceOver should automatically speak that without focusing it. We can test by triggering that event via some debug (maybe set innerText of aria-live element).
Similarly, after pressing Fold, perhaps a polite live message "You folded." Check if VO reads it (maybe after finishing current focus announcements).
Ensure focus order is logical: Press Tab on desktop or VO's rotor to see order. It should ideally skip over decorative items and go to primary controls. If we find any weirdness (like VO focusing an invisible element or reading something like "unlabeled button"), track that down.
Check if the focus highlight is visible when using keyboard (since voiceover on iOS might not show it because it uses its own focus, but on Mac with VO or just using Tab on desktop we can check). Make sure the outline or ring is clearly visible as we tab through, as earlier tested in styles.
VoiceOver on Mac (or NVDA on Windows):
Use keyboard navigation: e.g. with VO keys or Tab through. Ensure that the reading out corresponds to what element is (like "Stats menu button, collapsed, press to expand" if we provided such ARIA).
Expand FloatingActionMenu via keyboard (focus + Enter): see if sub-buttons are accessible in sequence.
Open bottom sheet via keyboard and ensure focus is trapped in it and the SR reads its content.
Press Esc to close bottom sheet and ensure focus returns appropriately.
If possible, simulate a whole round with screen reader: we might not actually simulate a player's strategy, but we ensure that all needed info is conveyed:
E.g., after dealing flop, does the screen reader know the community cards? We might have to check how we labeled those. Possibly have VO read the community cards container (like "Board: 7 of hearts, 10 of clubs, 10 of diamonds").
If not automatically read, a blind user might swipe to find that container. We must ensure it exists in tab order or at least as an ARIA live. We planned to announce the flop via live region. Confirm that maybe via log or actual test: after dealing flop, an aria-live "Flop: ..." message should have been spoken.
Check that all controls have ARIA roles that make sense (buttons announced as buttons, etc.). If any announced just as "text" or "group" erroneously, adjust roles.
Contrast Re-check: Use a color picker on final UI for text vs bg if necessary to double verify, especially for any dynamic text on colored background (like if we color-coded something in HandStrength panel, ensure it's not too faint).
Focus & Keyboard:
Use only keyboard to play a hand on desktop: Press Start (Enter), then Tab to Fold (Enter) or use shortcuts, etc. Ensure you can do everything: if something like raising amount selection was needed, ensure that is reachable (maybe arrow keys to adjust slider if it appears, then Enter to confirm raise).
Check that no component steals focus unexpectedly or traps it unintentionally:
For example, if a toast appears, it shouldn’t grab focus (we didn't set it to).
If bottom sheet open, focus should loop inside, test Tab cycling (Focus should go Close -> content links if any -> back to Close).
Ensure you can close bottom sheet with Esc.
If side panel (HandStrength) is open in overlay mode, see if you can still Tab to background controls – we might want to trap focus if it covers content. If we didn't trap it, a user could inadvertently tab to hidden buttons. Better, when we open it as modal on md, we should probably trap focus in it like a dialog. If not done, consider adding inert to background. We test if Tab goes behind panel or not.
Haptics & Sound:
On a device with vibration, ensure that actions produce haptic feedback. For example, fold (maybe we set medium impact?), see if you feel it. All-in heavy impact should be notable. If not easily felt, might be because Telegram might not allow it if not triggered by user gesture? But our calls are inside event handlers, so should work.
Try toggling device silent mode on/off to see if haptics still happen (they should, as haptics typically do even if silent mode).
Sound:
Ensure sound toggle (if any) works: e.g. turn sound off, perform an action that normally has sound (deal card, bet) and confirm no sound plays. Turn on, do it, sound plays.
Listen that each intended sound does play: card shuffles, chip clinks, etc., at appropriate times.
Check volume levels relative to each other (we don't want chip sound overshadowing card sound too much). Might adjust if one is too loud or quiet.
Test on both iOS Safari (which sometimes doesn’t allow sound until user interacts – but since our game is interactive from start, likely fine) and Android Chrome. Possibly also in the Telegram webview if possible, as some webviews might restrict auto-play sound. Since our sounds triggered by user events, it should be fine.
If any sound overlaps weirdly (like two chip sounds play nearly together causing a jarring effect), consider spacing them out or using one combined sound. We can note if any audio mixing issues.
Also test that when multiple different events happen quickly, you do hear all or at least the most important (e.g. if someone bets (chip sound) and immediately next card dealt (card sound), do they clash? They might just play concurrently. It's probably okay, but ensure it doesn't produce glitch or distortion. If necessary, we might slightly delay one for clarity.
If possible, test sound in both Light and Dark mode (shouldn't matter, but just ensure no audio differences if theme toggles something).
Check that no console errors about audio playback (some browsers log if couldn't play due to user gesture requirements; if we see any, adjust code to ensure audio context unlocked on first user tap).
Snapshot Protocol & Regression:
We will run our automated snapshot script (npm run snapshots, which uses Playwright). This will capture the UI in various states:
e.g. snapshot_waiting_light.png, snapshot_ingame_dark.png, etc. We will compare these to expected images (once we set baseline).
For each snapshot:
Ensure all UI elements are properly placed and visible (no cut text or overlapping).
Example Snapshots to verify:
Mobile waiting (light mode): should show table background, no community cards, 6 empty seats (or with placeholder names if we have AI names), "Start New Hand" button at bottom. Check: seats are arranged correctly (not overlapping each other; bottom seat centered; etc.), Start button is centered and above safe area margin.
Mobile in-hand (dark mode): after dealing preflop to user. Expect to see two hole cards at bottom center (face-up for user), maybe other seats have card backs or nothing. Fold/Check/Bet/All-in visible. Check: the cards are at correct positions, not clipping out of seat, action buttons correctly labeled and spaced.
After flop (some mode): table with 3 community cards. Check them: are they centered and not overlapping the pot or each other? If pot text is shown, ensure it's positioned clearly near them.
Tablet portrait (md) mode mid-game: Check that left panel toggle is visible (maybe a small icon); right panel still hidden (since <lg). The table maybe a bit smaller to fit some UI. Ensure nothing overlaps incorrectly (especially check that floating menu might not be needed on tablet if we show left toggle directly).
Desktop (lg) mid-game: Snap should show left HandStrength panel open, right history panel open. Check: The table is between them and sized properly (not tiny). Content in side panels is readable (not cut).
Desktop with maximum players and info: If possible, simulate a scenario in snapshot with many chips in pot, maybe side pot, and see if UI can display those (like if pot number is large, does it overflow pot display?). If not simulated, skip.
Any error state snapshot (if we had one): e.g. if a player is out of chips, do we show "Busted" on their seat? If so, ensure styling correct.
After verifying snapshots, we mark them as baseline for future regression tests. For each future code change, run snapshots to catch unintended layout shifts or broken component (the test will highlight pixel diffs).
We'll also incorporate manual regression checks for interactive stuff not captured by static snapshots:
e.g. verifying that fold gesture still works after any refactor.
re-run the keyboard and screen reader test after any major code changes to ensure no accessibility feature broke.
Through these exhaustive QA steps – combining automated snapshots, cross-device manual testing, accessibility audits, and performance profiling – we ensure the TeleHoldem UI meets the high bar for production quality. We will document any issues found and address them before release. QA is iterative; after fixes, we re-run relevant tests to confirm resolution (especially for critical issues like layout problems on certain devices).
9. References to Working Patterns
Our design and implementation decisions are informed by established patterns from successful poker apps and platform UI guidelines:
Mobile Poker Gestures: We took cues from apps like World Poker Club and PartyPoker’s mobile clients which introduced intuitive gestures for actions. For example, double-tap to check/call and flick-up to fold are inspired by World Poker Club’s gesture system
medium.com
, which proved to be a fast and natural input method. Similarly, the drag-to-raise mechanism parallels PartyPoker’s swipe-in chips interface
pokerfuse.com
, enabling one-handed betting without fiddling with small sliders.
Touch Target Guidelines: We adhered to Apple’s and Google’s recommended minimum sizes (44pt/48dp) for interactive elements
ux.stackexchange.com
 to ensure taps are error-free. This is consistent with general mobile best practices and reduces “fat-finger” mistakes, crucial in a game where a wrong tap (fold instead of call) is costly. Nielsen Norman Group also emphasizes at least ~1cm targets
lukew.com
, which our design meets or exceeds.
Safe Area and Notch Handling: Following Telegram Mini Apps guidance, we made sure to respect safe areas
core.telegram.org
. Many modern apps (e.g. TikTok, Instagram) use the safe-area-inset CSS for full-screen experiences, as do games. We ensure no UI element is hidden behind notches or cutouts by using env(safe-area-inset-*) environment variables, as recommended by Apple and Telegram docs
core.telegram.org
.
Visual Theming with Design Tokens: Our use of CSS variables for theme colors and spacing is influenced by the Shadcn/UI design system conventions
infinum.com
. By referencing tokens like --brand-600 and using Tailwind’s bg-brand-600 classes, we ensure consistency and easy theming. This approach is similar to how Material Design and other systems define a palette and apply it uniformly. It allows dark mode support and potential reskinning with minimal code changes, a pattern proven in many design systems.
Color Contrast & Accessibility: We followed WCAG guidelines for contrast
webaim.org
, ensuring our text (especially critical info like card labels and chip counts) is readable against backgrounds. This is a pattern mandated in all modern UI; for instance, Google’s Material Design and Apple HIG both require sufficient contrast for text. We also implemented clear focus indicators, aligning with upcoming WCAG 2.2 focus appearance rules
ux.stackexchange.com
, to accommodate keyboard users.
Action Bar Layout: The grouping and state-driven showing of Fold/Call/Raise/All-in mirrors typical online poker UIs, such as PokerStars or Zynga Poker, where unavailable actions are hidden to streamline decisions. This reduces clutter and guides the user to valid choices
yaninagames.com
. We specifically include the bet amount on the Call button (e.g. "Call 100") as it’s a known best practice to prevent mis-clicks and inform the user
yaninagames.com
. Real poker clients always show the call amount on the button for clarity.
Seat Arrangement: The elliptical positioning of seats around the table is standard in poker apps (usually symmetric). Our approach to place seats at fixed angles ensures each seat is legible and not overlapping – a pattern you’ll see in PokerStars’ 6-max tables (UI screenshots show similar spacing). The formula approach (cosine/sine distribution) is a common technique in game development for circular seating.
Turn Indicator: Highlighting the current player’s seat with an animation (glow or ring) is derived from common practice in live poker software and even physical poker tables (which often have a dealer button or light). For example, Zynga Poker highlights the active player’s avatar with a glowing ring. This clear indicator helps players follow the action and is something we replicated
yaninagames.com
.
Haptic Feedback Integration: Mobile games increasingly use haptics to enhance feedback – for instance, Apple’s HIG encourages using haptics for actions to supplement visuals. We followed those guidelines by using light impacts for minor actions and heavier for dramatic ones
core.telegram.org
core.telegram.org
. The pattern of using notificationOccurred("success") on a win or impactOccurred("heavy") on all-in is modeled after Apple’s recommended use cases (success, warning, failure notifications map to certain UX events).
Audio Cues: We align with the convention that card games provide audio feedback: the “card dealing” sound and chip clinking are staples in apps like PokerStars and WSOP. These auditory signals reinforce the actions (e.g. PokerStars’ client plays a distinctive chip sound when a bet is made). By including them, we tap into user’s learned expectations, improving the sense of immersion.
Bottom Sheet for Mobile Info: Using a slide-up bottom sheet for supplementary info (hand stats, etc.) is influenced by general mobile UX (material design bottom sheets) and specifically by Telegram’s own examples of mini-app interfaces. It’s a pattern that keeps primary content (the game) accessible while allowing peek/pop-up of secondary content. We implemented it to ensure mobile users can access stats without leaving the game view, as suggested in Telegram mini app best practices (adaptive design principle)
bazucompany.com
.
Responsive Design Testing: We drew on the principle from YaninaGames blog: “The interface should shift naturally between different screens… test on tablets, phones, desktops”
yaninagames.com
. Our multi-breakpoint approach and extensive QA on various devices reflect this pattern of thorough responsiveness. We ensured the core gameplay is consistent and functional on all target sizes, as a successful poker app must be.
Incremental Reveal (Tutorial): Though not fully detailed in plan, we considered guiding new users (like highlighting the swipe gestures or showing a one-time tooltip). This idea comes from onboarding patterns common in mobile games where the first use might show an arrow “Double-tap to check”. If time permits, we’d implement such tips in a non-intrusive way. It’s mentioned here as a reference pattern: many apps do a quick tutorial overlay for complex controls.
Implementation Process: We followed a mobile-first, component-driven development style, reflecting modern web dev patterns. Breaking the UI into independent components (PlayerSeat, PlayingCard, etc.) is informed by React best practices and how design systems (Material, Lightning, etc.) structure things. This ensures maintainability and reusability.
By grounding our design in these proven patterns and guidelines, we aim to deliver a UI that feels familiar to poker enthusiasts yet optimized for the Telegram mini-app context. The references from real apps and official guidelines backed each major decision – from input methods to visual feedback – to meet user expectations and platform standards.
10. Implementation Plan (Sequenced & Actionable)
We will implement the TeleHoldem UI in a series of clear tasks (roughly 1-2 hours each), ensuring at each step we have a working, testable increment. Below is the step-by-step plan with file targets and validation after each step: Day 1 Tasks:
Setup Breakpoints & CSS Variables – Files: client/src/index.css, tailwind.config.js if needed.
Add xs breakpoint at 480px to Tailwind config (if not already). In tailwind.config.js, under theme.screens, set xs: "480px". This allows us to use xs: utilities.
Define Safe Area CSS vars: In index.css, ensure we have:
:root {
  /* Already likely present: theme colors, etc. */
  --safe-area-inset-top: env(safe-area-inset-top);
  --safe-area-inset-bottom: env(safe-area-inset-bottom);
  --safe-area-inset-left: env(safe-area-inset-left);
  --safe-area-inset-right: env(safe-area-inset-right);
}
If using tailwind-safe-area plugin, use that accordingly.
Aspect Ratio Utilities: Tailwind v3 has native aspect-[w/h]. Add custom aspect ratios:
e.g. in CSS:
@screen xs { .table-container { aspect-ratio: 185/100 } }
@screen sm { .table-container { aspect-ratio: 185/100 } } /* apply same as xs-sm perhaps */
@screen md { .table-container { aspect-ratio: 3/2 } }
/* default (under xs): */
.table-container { aspect-ratio: 190/100; }
Alternatively, use inline style in component with conditional classes. But a CSS approach centralizes it.
Spacing/Radius Tokens: Verify index.css defines things like --radius-sm, etc. If not:
Add under @theme: e.g.
@theme {
  --radius-sm: 0.125rem;  /* 2px */
  --radius-md: 0.375rem;  /* 6px */
  --radius-lg: 0.75rem;   /* 12px */
}
Tailwind might already have classes rounded-md mapping to some px, but these tokens ensure consistency with shadcn. (If shadcn's base has those CSS variables, use them. Check if rounded-md in our code uses the var – if not, might not need to add manually.)
Safe Area in Tailwind classes: If using p-safe utilities from a plugin, great. Otherwise, plan to use inline style for padding: e.g. style attr in component for paddingBottom: env(safe-area-inset-bottom).
Validation: Run npm run build:css (if needed) to ensure no errors from config. Use devtools on a page (if available now) to see that aspect-ratio class is applied to .table-container. We might have to verify once we implement table-container element. At least ensure classes like xs:aspect-[185/100] exist if possible by scanning compiled CSS.
Layout Structure & Table Container – Files: pages/poker-game.tsx and possibly new layout CSS.
Implement main layout markup: In poker-game.tsx (assuming this is a React component rendering the game):
Wrap content in a main tag with class relative w-full h-full bg-table (assuming bg-table is a tailwind class from theme for table background color or image). If not, define .bg-table in CSS (maybe a dark green).
Inside main, create a div for layout:
<div className="flex flex-col md:flex-row w-full h-full">
  {/* Left panel placeholder */}
  <aside id="handStrengthPanel" className="hidden md:block md:relative md:w-72 lg:w-80">
    {/* content will be filled later */}
  </aside>
  {/* Table center */}
  <div className="relative flex-1 flex flex-col items-center justify-center overflow-hidden">
    {/* Table container oval */}
    <div className="table-container relative w-[95%] max-h-[80vh] bg-[color:var(--table-bg)] rounded-[50%] md:rounded-[40%] flex items-center justify-center">
      {/* Community cards and pot will go here */}
    </div>
    {/* Action bar at bottom */}
    <div className="action-bar absolute bottom-0 inset-x-0 pb-[env(safe-area-inset-bottom)] px-4">
      {/* Start Hand or ActionControls will render here */}
    </div>
  </div>
  {/* Right panel placeholder */}
  <aside id="historyPanel" className="hidden lg:block lg:relative lg:w-64">
    {/* content will be filled later */}
  </aside>
</div>
Explanation: We use flex-col on mobile (top to bottom), switching to flex-row on md (left panel + table). The table container gets width 95% to leave some side margin on mobile, and max-h 80vh to cap height. rounded-[50%] md:rounded-[40%] is a quick approach to an oval shape (50% on mobile = circle if aspect, 40% on md to make more racetrack shape). We'll refine this shape if needed. We set table background via CSS var --table-bg (define in index.css: maybe --table-bg: #073a07 for a poker table green).
Integrate safe-area padding: In action-bar div, we used pb-[env(safe-area-inset-bottom)] directly (Tailwind might not parse env() well unless configured). If that class doesn't work, use style:
<div className="action-bar ..." style={{ paddingBottom: "env(safe-area-inset-bottom)" }}>.
Also add pt-[env(safe-area-inset-top)] to main or top container if needed when we add top elements.
Note: We haven't output any actual PlayerSeat or ActionControls yet, just layout containers. Ensure NUM_PLAYERS = 6 is considered for seat placement soon.
Seat Position Container: The table container will host absolutely positioned PlayerSeat components. For now, create a placeholder mapping:
{Array.from({ length: NUM_PLAYERS }).map((_, i) => (
    <PlayerSeat key={i} index={i} />
))}
Place that inside .table-container div. The PlayerSeat will be absolutely positioned via styles to come. We pass index for calculation.
Seat Positioning CSS: In index.css or a new CSS module:
Define the formula – we can either do inline style in component using index + trig, or CSS using nth-child. Perhaps easier in React: in PlayerSeat component (we will implement next tasks) do calculation using JavaScript. For now, add a placeholder style:
<div className="player-seat absolute" style={positionForIndex(index)}> ... </div>
We'll implement positionForIndex function next when doing PlayerSeat. It's okay if seats overlap now; we'll fix logic soon.
Validation: Start app and manually inspect layout:
Ensure left and right aside are hidden at mobile sizes and appear at breakpoints by resizing browser.
Use devtools to verify .table-container got the aspect ratio (e.g. style aspect-ratio:1.9 on mobile).
Check the table div is centered and not overflowing vertically (should be capped by 80vh).
If possible, temporarily give .table-container a visible background color to confirm its shape and size on screen.
Ensure action-bar is at bottom with expected padding (simulate on device with notch via devtools by adding appropriate environment variables or just trust the env(safe) if device doesn't have it that var = 0).
No console errors about env() usage.
At this stage, clicking "Start Hand" or such isn't integrated, but we just want layout correctness. Possibly put a temporary element in action-bar like <button>Test</button> to see it's positioned above bottom.
PlayerSeat Component – File: components/PlayerSeat.tsx
Create PlayerSeat.tsx with props as defined. For now, maybe just props: index (for placement), name, chips, status flags (folded, current). We'll integrate actual game data later. Use default dummy values for now (like name "Player 1", chips 1000 for all).
Layout inside seat: likely a container div with fixed size (like 50px diameter avatar + text). For initial test:
const PlayerSeat = ({ index, name="Player"+index, chips=1000, isCurrent=false, hasFolded=false, isDealer=false }) => {
  // compute position
  const angle = (90 + 60*index) % 360;
  const rad = angle * Math.PI/180;
  const rx = 45; const ry = 45; // radius percentages
  // Actually, we'll use 50% center and offset by cos/sin * 50%:
  const x = 50 + rx * Math.cos(rad);
  const y = 50 + ry * Math.sin(rad);
  return (
    <div className={"player-seat"} style={{
      position: 'absolute',
      top: `${y}%`, left: `${x}%`,
      transform: 'translate(-50%, -50%)'
    }}>
      <div className={"avatar w-12 h-12 rounded-full bg-gray-500 relative" + (isCurrent? " ring-4 ring-yellow-400 animate-pulse": "")}></div>
      <div className="name text-xs text-white text-center">{name}</div>
      <div className="chips text-xs text-yellow-300 text-center">{chips}</div>
    </div>
  );
};
export default PlayerSeat;
This uses an basic approach: radius 45% horizontal/vertical so seats not at extreme edge. We can refine rx, ry per device, but for now constants. Possibly measure container aspect to adjust, but skip for now.
Add styles in CSS if needed: e.g. .player-seat .avatar background etc. But we used Tailwind classes mostly.
Validation: Refresh game view. Now you should see 6 player-seat elements around the table:
Check their approximate positions: one at bottom center (index0 should be bottom if angle formula right? Actually index0: angle 90 -> bottom, yes), index3: angle 270 -> top, others around. Confirm symmetry.
Likely they might be slightly inside table area by 5%. That margin ensures not cut off.
Verify the transform centers them correctly (so avatar centers at those coords).
The dummy avatars should not overlap each other or the community center significantly. There will be some gap.
If any overlap or go out of .table-container, adjust rx/ry. Eg if corners too close to edge, reduce rx to 40.
On resizing, since percentages, they should maintain relative positions fine as aspect is fixed. Check at md and lg sizes if still okay (table oval changes shape slightly but our fixed rx, ry might need adjusting by breakpoint if oval changes a lot. We can consider: on md+, maybe use rx=47, ry=42 or something. But fine-tune visually if needed.)
Confirm isCurrent style: maybe force one isCurrent=true in one seat and see ring appear. Confirm ring is visible (we gave ring-yellow-400).
No runtime errors (like cos on something undefined).
ActionControls Component & Start Hand logic – Files: components/ActionControls.tsx, maybe poker-game.tsx to integrate.
Implement ActionControls UI: This component receives game state (canCheck, etc.) and current player's perspective. For now, we'll simulate one scenario:
If a phase === 'waiting', show a "Start New Hand" button.
Else, show the relevant action buttons. For initial dev, we could ignore game logic and always show Fold, Check, Bet, All-in (one scenario).
Actually, to test layout, show all four but disable inappropriate ones:
<button className="btn fold">Fold</button> <button>Check</button> <button>Bet</button> <button>All-in</button>.
Use Tailwind classes for styling: e.g. className="px-4 py-2 rounded-md text-white bg-red-600" for fold, etc.
Tailwind styling for buttons: We can define a base style: in CSS or reuse shadcn button if available. Possibly:
const base = "min-w-[64px] min-h-[48px] mx-1 py-2 px-3 rounded-md text-sm font-semibold focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-2";
Then variant colors: fold (bg-red-600 hover:bg-red-700), call/check (bg-blue-600), bet/raise (bg-blue-600 as well), all-in (bg-yellow-600 maybe).
Also add disabled style: e.g. disabled:opacity-50 disabled:cursor-not-allowed.
Insert ActionControls: In poker-game.tsx, inside .action-bar div:
{gamePhase === 'waiting' 
   ? <button onClick={startHand} className="start-hand-btn ...">Start New Hand</button>
   : <ActionControls {...props} />
}
The startHand function would set phase to something and deal cards (we can stub game logic). For UI, just hide the button.
For now, define gamePhase in state of PokerGame component:
const [phase, setPhase] = useState<'waiting'|'preflop'|'flop'|...>('waiting');
Implement startHand = () => setPhase('preflop'); and also maybe generate dummy data (like assign cards to players).
Pass needed props to ActionControls: e.g.
<ActionControls canCheck={true} currentBet={0} playerChips={1000} onFold={()=>{...}} onCheck={()=>{...}} ... />
For now, dummy handlers that console.log or update internal state like maybe mark player as folded.
Validation:
Load the page: it should show the Start New Hand button.
Click it: it should hide and show action buttons (phase toggled to preflop).
See that the four action buttons are visible, properly sized (check they meet 48px height).
Try resizing: ensure they remain in row with wrap or not. If on very small screen they might get tight; ensure they don't overflow container. Possibly they wrap if container narrow. That might be okay if neat, but we prefer them in one line. If too tight, consider reduce margin or text shorter. We'll see.
Pressing them doesn't do much now, but ensure no weird focus issues. Pressing Tab should cycle through them in order.
Check visual style: color contrast of white text on colored background (like bg-blue-600 with white text should be OK). Red on dark maybe borderline; ensure red is bright enough (maybe use red-600 which is #dc2626 on black is ~5:1, which is just at threshold for small text? Actually #dc2626 on #000 yields ~5.2:1, good).
Also verify safe-area bottom padding: On a device with a home indicator (simulate by adding a big dummy safe-area value in devtools: document.documentElement.style.setProperty('--safe-area-inset-bottom','50px')), see that the action bar indeed has that extra padding and that background covers it (if we gave action-bar a background color or it's on table? We might need to give action-bar a background color to avoid table showing under safe padding. So possibly add bg-black bg-opacity-50 to action-bar).
CommunityCards & Pot Display – Files: components/CommunityCards.tsx, components/PotDisplay.tsx
CommunityCards: Create a simple component that takes an array of card objects (or strings). It will render a horizontal list of PlayingCard components.
For now, simulate cards = ["Ah","Kd","Qs"] for flop once phase=flop.
Use a container div with class e.g. flex space-x-1. Each PlayingCard can be represented by an emoji or placeholder if card component not ready. Perhaps we use PlayingCard comp from earlier (if implemented suits).
Place CommunityCards in the table container:
In poker-game.tsx, inside table-container div:
<CommunityCards cards={communityCards} />
<PotDisplay amount={pot} />
CommunityCards will absolutely position itself probably to center? Actually, if flex container with justify-center, we could let the parent .table-container be flex items-center justify-center (we did that). But that centering applied to content inside table container (the seats are absolute though). We might simply put CommunityCards as a normal child, it will be centered by that flex center.
However, since we placed seats absolute, maybe table-container is not flexing them. Actually, we did flex and seats absolute so they don't affect layout. So center container effectively remains empty content for flex center? We might need to add an extra wrapper for community+pot and let that be centered with absolute to avoid interference from seats. Simpler: add a wrapper:
<div className="relative z-10"> 
   <CommunityCards ... />
   <PotDisplay ... />
</div>
and maybe not use flex on table-container or adjust. But let's attempt easier:
Keep table-container as position relative and not flex center (the seats are absolute anchored to 50% anyway). Place community and pot with absolute positions too.
e.g.
.community-cards { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -10%); }
(slightly above center for pot text clearance).
And .pot-display { position: absolute; top: 40%; left: 50%; transform: translateX(-50%); } for above flop.
We'll style accordingly.
PotDisplay: Render simple text "Pot: $X". Style: text-white text-sm font-semibold possibly with a subtle background for readability (maybe a semi-transparent dark background behind text, with padding 2px 4px, border-radius 4px).
Validation:
Simulate that after flop, communityCards = ["A♣","J♦","7♥"], pot=150. If we haven't integrated game state fully, manually set these when phase changes in code.
Check that the community cards show up centered horizontally. Possibly our approach with absolute center might need fine adjustment. If off, adjust transform (maybe -50%,-50% would center exactly, but we might want them a bit below the vertical center line, so maybe translateY(-30%)).
Ensure the spacing between cards is fine and they are moderately sized. If using text placeholders, not crucial, but eventually these will be actual card images (we will do next tasks).
Pot display should appear above or near the community cards, not overlapping them. And text large enough to read.
On small screens, confirm these don't overlap seats. E.g., top seat and community might be close. Possibly reduce how high pot is (40% is okay).
On large screens, they might appear further due to different aspect. We'll test on various sizes and adjust percentages.
PlayingCard Component (Graphical) – File: components/PlayingCard.tsx
Implement card visuals: Possibly simplest: use Unicode characters for suits and letters for ranks in a styled div to represent a card.
E.g.
const PlayingCard = ({ card, faceUp=true }) => {
  const [rank, suit] = parseCard(card); // e.g. "A", "h"
  if (!faceUp) return <div className="card back w-8 h-12 bg-blue-500 rounded text-center">🂠</div>;
  const suitSymbol = { 'h':'♥', 'd':'♦', 'c':'♣', 's':'♠'}[suit];
  const isRed = suit==='h' || suit==='d';
  return <div className={"card face w-8 h-12 bg-white rounded border flex flex-col justify-between p-0.5 " + (isRed?"text-red-600":"text-black")}>
    <span className="text-[10px] font-bold">{rank}{suitSymbol}</span>
    <span className="text-[10px] font-bold rotate-180">{rank}{suitSymbol}</span>
  </div>;
}
This produces a mini card with rank+suit top-left and bottom-right rotated (like actual card).
Style: border:2px solid black maybe for card outline. We can refine sizes to look proportionate.
Use PlayingCard inside CommunityCards:
In CommunityCards, map each card code to <PlayingCard card={code} />.
Use PlayingCard for hole cards in PlayerSeat possibly later (we might overlay them near player's seat).
Validation:
Ensure the Unicode suits display properly (some fonts might not show colored heart, but we applying text-red, so hearts and diamonds are red, clubs spades black).
The card size (8w x12h as used = maybe 32px x 48px if 4px base, we used absolute size? Actually w-8 => 2rem=32px, h-12 => 3rem=48px on 16px root).
Might be small on high res. Check if maybe scale up to w-10 h-14 if needed.
Check that in community, the three card images look like distinct cards not overlapping. If too small on desktop, we could add responsive classes (e.g. md:w-10 md:h-14).
They should be legible though (rank and suit).
Flip logic: We used faceUp always. Possibly incorporate if we want to test flip anim, but skip for now.
FloatingActionMenu & BottomSheet – Files: components/FloatingActionMenu.tsx, components/BottomSheet.tsx
FloatingActionMenu: Implement as a small button + menu:
In poker-game.tsx, include <FloatingActionMenu actions={...} /> somewhere – likely absolutely positioned bottom-right above action bar. Possibly inside the .action-bar but positioned absolute so it doesn't disrupt the row? Actually, better outside:
Place it in main or table container with fixed pos:
e.g.
<FloatingActionMenu className="lg:hidden" /> at bottom of PokerGame return (since on desktop we won't show).
In FloatingActionMenu component:
State open/closed.
Render a main button:
<button onClick={()=>setOpen(!open)} className="w-12 h-12 rounded-full bg-gray-700 text-white text-xl">☰</button> (or use FontAwesome icon if avail).
If open, render each action:
e.g.
{open && <div className="absolute bottom-16 right-0 flex flex-col items-end space-y-2">
     {actions.map(act => 
       <button key={act.label} onClick={()=>{ act.onClick(); setOpen(false)}} 
         className="w-10 h-10 rounded-full bg-gray-800 text-white text-center text-sm" aria-label={act.label}>
         {act.icon}
       </button>)}
 </div>}
We'll use simple text or emoji as icons for now (e.g. 📊 for stats, 📜 for history, 🔊/🔇 for sound).
Positioning: main button could be fixed bottom: env(safe-area-inset-bottom) + 8px; right: 8px;. But simpler: give main a container with className="fixed bottom-4 right-4" plus safe-area offset. Actually incorporate safe bottom: style={{ bottom: \calc(env(safe-area-inset-bottom) + 1rem)` }}`.
Ensure actions pop above main (we did bottom-16 above main's bottom to stack vertically).
BottomSheet: A generic component for mobile panel:
For now, implement minimal: if visible, render a div fixed full-screen bottom 0 with a semi-transparent dark backdrop and an inner content panel.
Example:
const BottomSheet = ({ visible, title, children, onClose }) => {
  if(!visible) return null;
  return (
    <div className="fixed inset-0 z-50">
      <div className="absolute inset-0 bg-black bg-opacity-50" onClick={onClose} />
      <div className="absolute bottom-0 inset-x-0 bg-white rounded-t-xl p-4 max-h-[90%] overflow-y-auto">
        <div className="flex justify-between items-center mb-2">
          <h2 className="text-lg font-bold">{title}</h2>
          <button onClick={onClose} className="text-2xl">&times;</button>
        </div>
        <div>{children}</div>
      </div>
    </div>
  );
};
This covers basics: clicking backdrop or × calls onClose. We don't implement drag for now.
Use it in PokerGame: maintain state e.g. showStatsSheet, showHistorySheet.
FloatingActionMenu actions' onClick will set those true.
e.g. actions=[ { label:'Hand Stats', onClick: ()=>setShowStats(true) }, { label:'History', onClick: ()=>setShowHistory(true) } ].
Then in JSX, add <BottomSheet visible={showStats} title="Hand Strength" onClose={()=>setShowStats(false)}><HandStrengthIndicator ... /></BottomSheet>.
Similarly for History panel.
Validation:
On mobile (simulate small width), click the floating menu (☰): the two option buttons appear above it. Tap each:
Hand Stats: bottom sheet slides up (no animate, but appears). Title and presumably some content (maybe "Pair of Aces" etc. if we pass HandStrengthIndicator).
Tap outside or X: it closes. Test multiple times.
History: open sheet, see maybe placeholder text if we don't have actual content yet.
Check focus trap: we didn't implement but see if it's needed: currently user could tap backdrop easily or close. For keyboard, a risk but on mobile not crucial. We'll note but skip due to time.
On desktop (≥lg), FloatingActionMenu hidden via class, so those side panels should be accessible via sidebars automatically.
Check the floating button doesn't conflict with action bar (placed bottom-right outside action bar area).
Check safe-area: if on iPhoneX, ensure the floating button isn't hugging bottom too close (calc with env should push it up).
HandStrengthIndicator Panel – File: components/HandStrengthIndicator.tsx
Render something like:
const HandStrengthIndicator = ({ hand, draws, winPct }) => {
  // For now, accept props or use context game state
  return <div>
    <p className="text-sm">Best Hand: <span className="font-semibold">{hand || "High Card"}</span></p>
    {draws && <p className="text-sm">Draws: {draws}</p>}
    {winPct != null && <p className="text-sm">Win chance: {winPct}%</p>}
  </div>;
};
When integrating with game logic, we'd compute hand from hole+community.
Integrate into left panel on desktop:
In PokerGame, in the left aside (#handStrengthPanel):
phase !== 'waiting' && <HandStrengthIndicator hand={computedHand} draws={computedDraws} winPct={computedWinChance} />.
On medium screens (md only), we have left panel toggled overlay not implemented. But user can use bottom sheet instead, so it's okay.
Validation:
On desktop after starting hand, left panel now shows something like "Best Hand: Pair of 7s" if we compute. If we haven't computed, maybe just "High Card Ace".
Check styling and ensure it's not overflowing panel width (72 or 80 width).
On mobile, the sheet we open already contains HandStrengthIndicator (we added as children in bottomsheet).
Ensure text color contrast in panel (assuming panel bg white, text black or dark).
HistoryPanel Content – File: components/HistoryPanel.tsx (or can inline in aside for simplicity)
If we track actions, we would map them here. If not, just put "History not implemented".
On desktop, fill right aside with maybe a placeholder list:
<ul className="text-xs">
  <li>Hand 1: You won $150</li>
  <li>Hand 2: Alice won $200</li>
</ul>
On mobile, the history sheet uses the same component.
Validation: Confirm it appears on desktop (if visible by default on lg).
If empty, maybe we should hide aside on lg if no content? But spec said sticky column on lg regardless. We'll show placeholder for now.
Ensure scroll if content height beyond panel height.
Accept/Finish:
Clean up any console logs or placeholder text that might confuse user (like using actual card suits instead of "♠").
Test interactive flows one more time from start to finish (already covered in QA).
Write unit tests if required for functions (like seat position calculation outputs correct values).
Document any known limitations (maybe not all gestures implemented fully or not all edge cases).
Prepare baseline screenshots for final UI to serve as reference for acceptance criteria.
Throughout implementation, after each chunk, re-run npm start and manually verify UI as described (especially layout and interactions). After all tasks, we’ll run the full QA checklist (section 8) to catch any remaining issues. By following this plan step-by-step, we modify the specified files in manageable diffs:
Breakpoint & CSS (index.css, tailwind.config.js)
Layout markup (poker-game.tsx)
PlayerSeat (new file + usage in poker-game)
ActionControls + hooking up phase logic (ActionControls.tsx, poker-game for state)
CommunityCards + PotDisplay (new files + usage)
PlayingCard (visuals, used by CommunityCards)
FloatingActionMenu + BottomSheet (new comps + integrated in poker-game)
HandStrengthIndicator + HistoryPanel (content in asides and bottom sheets)
Each incremental change will be verified via the dev server and committed, allowing easy rollback if something breaks layout drastically. We should commit after each major step, referencing the task (e.g. "Implemented responsive layout containers", "Added player seats with dynamic positioning", etc.).
11. Acceptance Criteria
We'll consider the plan successful when all the following criteria are met (each item is a binary pass/fail, testable via inspection or tools): Information Architecture & Layout:
 IA-1: The game view contains all specified regions: table area with 6 player seats, community cards, pot display, an action bar, a left stats panel (on md+), and a right history panel (on lg+) – confirmed by inspecting the DOM structure and comparing to design spec.
 IA-2: No critical UI element is off-screen or overlapping another at standard resolutions (320px wide up to 1280px). Verified via visually checking screenshots at min and max breakpoints that seats, cards, buttons, and panels are neatly within bounds (no horizontal scrollbar present).
 IA-3: The component hierarchy follows the plan: PlayerSeat components are children of the table container, ActionControls lives in the action bar, panels are in aside elements (checked by reviewing poker-game.tsx JSX for correct nesting).
Visual System & Tokens:
 VS-1: Typography sizes adjust per breakpoint: e.g. on mobile, body text ≈14-16px and headings ~20px; on desktop, panel titles ~28px. Verified by checking computed font-size in devtools at .handStrengthPanel h2 on desktop (should be ~1.75rem or 28px)
zignuts.com
.
 VS-2: Colors and spacing utilize CSS variables: e.g. background uses var(--table-bg), brand colors via bg-brand-600. Confirmed by inspecting computed styles (should see ...color: hsl(var(--...)) or similar). The UI must look consistent in light vs dark mode (tested by toggling theme, UI still legible).
 VS-3: Interactive states are properly styled:
Hover (desktop): Buttons get a visible hover style (slightly lighter/darker background) – test by mouseover a Fold button, confirm background darkens by ~10%.
Focus: When a button is tab-focused, it shows a focus ring 2px offset and in high contrast color (e.g. yellow or white ring on dark background)
ux.stackexchange.com
. Verified by tabbing to All-in button and observing the outline (take a screenshot to measure contrast > 3:1 against adjacent color).
Pressed: On touch or click, the button provides feedback (e.g. momentary 0.95 scale down or darker background). Verified by pressing and holding a Raise button and seeing visible change.
 VS-4: All UI text meets contrast AA: e.g. white text on blue buttons (blue-600 vs white yields ~7:1, pass)
webaim.org
. Confirm with devtools contrast checker on a mid-tone component (e.g. pot text on green table – ensure text color has ≥4.5:1 against table background; adjust if needed).
Layout & Breakpoints:
 LY-1: Mobile (<768px): Left panel is not visible and right panel is hidden. Verified by opening at 375px width and confirming only table and action bar show (no stats/history sidebars present). FloatingActionMenu is visible (bottom-right).
 LY-2: Tablet (768px ≤ w <1024px): Left HandStrength panel can be toggled via a button (or appears overlay). Verified by resizing to 800px: a Stats toggle icon is present (visible and clickable) and clicking it slides in the stats panel overlaying part of table. Right panel still hidden in this range (no history shown).
 LY-3: Desktop (≥1024px): Both left and right side panels are visible as sidebars. Verified at 1280px: the HandStrength panel occupies ~300px on left with content, the History panel ~250px on right. The main table is centered in remaining space without overlap, and no horizontal scroll appears (table and two panels fit within viewport).
 LY-4: The table container maintains correct aspect ratios: in screenshots,
at 360px width, measured table height is ~190px (within 5% of 360/1.9),
at 600px width, height ~324px (close to 600/1.85),
at 1024px width, height ~683px (approx 1024/1.5).
No table stretching beyond max-height (e.g. at 1280×800, table height <= 800px and bottom action bar is accessible). Confirm by measuring table element size in devtools at these widths.
 LY-5: Player seats are correctly positioned around the table at all sizes (no collisions or off-screen seats). Verified by visual inspection of positions in portraits and landscape:
Check in iPhone SE screenshot: all 6 avatars are distinct and fully on table (none cut at edges).
Check in iPad landscape: seats might be further apart but still evenly spaced around oval.
Use devtools to ensure, for each seat element, its coordinates (left, top) place it within table bounds (maybe log or just eyeball that none has left<0 or top<0 in container coordinates).
Component Behavior & States:
 CB-1: Action Buttons Visibility: Only appropriate buttons are shown for each state:
In a test hand with no current bet, the action bar shows “Fold, Check, Bet, All-in” and no Call (since canCheck true).
If a bet is present (canCheck false), the bar shows “Fold, Call $X, Raise, All-in” (Check and Bet are replaced).
Verified by simulating state (set canCheck false, currentBet>0) and seeing the DOM contain a "Call" button and not "Check".
 CB-2: Buttons enable/disable correctly:
When it’s player’s turn, all allowed actions buttons are enabled (clickable).
If player is all-in or it’s not their turn, action buttons are either hidden or disabled (no clickable action). Verified by simulating chips=0 (all-in) and confirming perhaps Fold/Call are disabled (or the action bar is hidden because no decision to make). Also, after acting, if our code hides them, confirm they disappear.
 CB-3: The Start New Hand button appears only when appropriate (phase waiting). Verified by finishing a hand (set phase back to waiting) and observing the "Start Hand" button visible at center of action bar, and it disappears once clicked (phase changes).
 CB-4: Action triggers:
Pressing Fold, Check, Call, etc. invokes the handler and updates game state accordingly. This is harder to auto-verify, but we can attach a console log or state change: e.g. clicking Fold sets hasFolded=true on user seat. Verified by inspecting state after clicking (e.g. user's seat icon goes dim or console output appears).
Similarly, Start Hand button triggers dealing (phase->preflop, etc.). Confirmed by seeing community cards or phase state change after clicking.
 CB-5: Keyboard Shortcuts: The keys F, C, R, A perform their respective actions when it's the player's turn:
In testing, pressing "F" results in the fold action being executed (e.g. a fold toast or state change occurs) with no other keys needed.
"C" triggers check or call as applicable (if canCheck, it checks, if call needed, it calls). Verified by scenario: canCheck true, press C -> game state moves to next phase (or console says "check"); canCheck false, press C -> pot increased or console "call").
"R" triggers raise UI: if we have no slider, it might just do a min-raise; verify by checking pot or console. If slider implemented, pressing R perhaps focuses the slider or opens raise overlay; verify that happened.
"A" puts the player all-in (chips go to pot or state chips=0). Verified by observing player's chip count after pressing A (should be 0/all put in pot) and an All-in toast/haptic triggers.
No adverse effect when not user's turn: pressing these keys when action bar is disabled does nothing (no fold erroneously happening). Verified by setting a flag not playerTurn and pressing keys, observing no state change or error log.
 CB-6: Touch Gestures:
Double-tap anywhere (except on a button) during player's turn yields a check/call. Verified on a touch device by double-tapping table background and confirming the game progressed as if "Check/Call" pressed (see pot or turn change). If not easily programmatically testable, manually validated.
Swiping up on player's hole cards triggers a fold. Verified by performing the gesture on an actual phone or emulator and seeing the fold occur (cards disappear or fold toast).
Dragging the chip stack into pot triggers a raise or all-in. Verified by dragging in mobile emulator: if release mid-way, a bet is placed (check log for "Bet X"); if dragged fully to pot, all-in occurs (player chips zero out). Also ensure dragging then cancel (sliding back or not crossing threshold) does not commit (player retains chips, no bet).
Swipe right on action area triggers call (if implemented). Verified by gesture: if user had call option and swiped right, the call executed (pot updated).
Gesture interference: ensure these gestures do not trigger unintended scroll/refresh: e.g. swiping up on iOS web could scroll page if not prevented. Verified by observing that our app is likely full-screen or intercepts touch events (should confirm no page scroll occurs during game interactions).
 CB-7: Hand Strength panel:
On desktop, it updates to reflect current best hand after flop/turn. Verified by checking content: e.g. after dealing flop, panel text says "Best Hand: Pair of X" or similar (not still showing preflop high card).
On mobile, accessible via bottom sheet: toggling open shows the same content; closing and re-opening updates as game state changes. Verified by e.g. open panel preflop (says "High Card"), close, deal flop, re-open panel now shows new info.
Panel fully hidden on mobile when not opened (no residual off-screen content).
 CB-8: History panel:
On desktop, it lists recent hands or actions in chronological order with no overflow beyond panel (scrollbar appears if needed). Verified by adding > panel height items to list and seeing scroll.
On mobile, bottom sheet history shows same content scrollably. Verified by opening history sheet on small device and checking user can scroll through entries to bottom.
Hide details on mobile when not needed (sheet closed, no history aside).
If "hidden < lg" is explicitly required, confirm at 1023px width, no right panel; at 1024px, panel appears.
Gestures, Haptics, Sound:
 GH-1: Swipe gestures threshold and response are user-friendly: e.g. flicking a card ~50px is enough to fold (no need to drag half screen), double-tap timing ~<=300ms works reliably. Verified by user testing (ensuring we don't need unnatural precision).
 GH-2: Haptic Feedback:
Light impact is felt on button tap and minor events (e.g. check, small bet). Verified on device by user feedback that a slight vibration occurs.
Heavy impact on All-in: Verified on device that a stronger vibration pattern occurs exactly when all-in action happens
core.telegram.org
.
Notification "success" on win: Simulated by awarding pot to user and confirming a distinct success haptic plays (tested by sense or using Xcode's sim for haptics if possible).
No haptic on events when not appropriate (like pressing disabled button yields nothing).
 GH-3: Sound Cues:
Dealing sound plays each time cards are dealt (listen for it on flop dealing; should hear 3 quick card swooshes).
Chip sound plays when bets are made and when pot is collected. Verified by making a bet and hearing chip clink, and at showdown hearing chips to winner sound.
Check sound (knock) and fold sound (card toss) are present and distinct. Verified by performing those actions and noting the difference in audio.
Volume balance: All sounds are audible but not overpowering; e.g. chip sound doesn't drown out card sound if they occur together (subjective check by QA).
Mute toggle works: turn off sound via UI and confirm no sounds play on actions; turn on and sounds resume. Verified by toggling and performing an action (no sound when off, sound when on).
 GH-4: No critical game info is conveyed by sound/haptic alone (we provide visual as well). Verified by analyzing that, for example, a fold produces a visual status (cards removed or text) not just a sound. So even with sound off or for hearing-impaired, nothing is lost (just immersion).
Accessibility (WCAG 2.1 AA compliance):
 A11Y-1: Contrast AA: All text has contrast >=4.5:1 (small text) or >=3:1 (large text) against its background
webaim.org
. Verified by tool on sample: player name text on dark table, button text on button backgrounds, panel text on panel bg. If any fail, adjust them.
 A11Y-2: Keyboard Navigability: A user can play the game using keyboard only:
Able to start hand (Tab to Start, Enter).
Tab through action buttons and activate one with Enter (or use shortcuts).
Access floating menu (Tab to it, Enter to open, then tab through sub-buttons, Enter to select Stats/History, Esc to close sheet).
No keyboard traps: focus moves logically (cycles through interactive elements then wraps or stops at end).
Verified by performing a fold/call with only keyboard (no mouse).
 A11Y-3: Focus Indicators: Every interactive element has a visible focus state meeting contrast guidelines
ux.stackexchange.com
. Verified by tabbing to each: action buttons (visible ring), floating menu main and sub-buttons (ring or highlight), close icons (outline visible).
 A11Y-4: Screen Reader Labels: All interactive controls are announced with meaningful names:
Confirm with a screen reader that Fold is read as "Fold button", Call as "Call 100 button", etc., and floating menu items have proper aria-label (e.g. Stats as "Hand Statistics button").
The player seats are announced with useful info (like "Player Alice, 1500 chips, folded"). Verified by swiping through elements with VoiceOver and hearing expected phrases (the aria-label strings).
Images and icons have alt or aria-hidden: e.g. card suits are announced as part of text "Ace of Hearts" (should be because we put text, not an image). Avatar images are either decorative or labeled by context (the seat label covers it).
 A11Y-5: Live Region Updates: Important dynamic events are announced:
When it's user's turn, a polite/assertive alert "Your turn" is spoken within ~1s. Verified by enabling screen reader, ending the previous action as another player so that it's user's turn, and hearing the announcement.
After a hand ends, result is announced (e.g. "You win the pot of $X"). Verified by forcing a showdown with SR on, and hearing the outcome announcement.
Toasts that appear visually (like "Bob folded") are tagged as aria-live=polite so SR reads them. Verified by performing an action with SR and noticing the event is spoken.
 A11Y-6: No SR Confusion: The screen reader does not announce any irrelevant or duplicate info:
Community cards are either summarized once or navigable sequentially, but not read twice. Verified by hearing how VO handles the community region: ideally we provided a container label "Board: ...", so VO reads that as one item, and doesn't focus each card image (we likely set aria-hidden on card images).
No control with missing name (checked via Axe or VO rotor listing "Button, unlabeled" - should not find any).
Focus order is logical: it should follow a sensible sequence (perhaps top bar controls -> table actions -> side toggles etc.). Verified via tabbing and VO rotor.
 A11Y-7: Reduce Motion compliance: If user sets reduce-motion, the game suppresses or shortens animations:
Verified by enabling reduce-motion and observing card dealing happens instantly (no lengthy animation) and seat highlight either static or off (no continuous pulse).
Ensure no needless motion remains: e.g. backgrounds don't animate, modals don't overly slide if not needed. Verified via manual observation under setting.
 A11Y-8: Responsive text scaling: If the user scales text (browser zoom 200% or OS font bigger), the UI still displays all critical info:
Verified by zooming page to 200%: all buttons still visible (maybe stack but accessible), text not cut (player names may truncate with ellipsis but still present), panels scroll if content large.
No overlapping due to large text (like pot text overlapping community cards should not happen; ensure container can expand or text wraps).
This can be checked by setting browser zoom and comparing layout to baseline (should maintain general structure, maybe larger but not broken).
Performance:
 PRF-1: On a typical device (e.g. mid-range phone), animations run at ~60fps with no noticeable lag. Verified by performing a card deal or chip movement and visually confirming smoothness (no stutters). Could also use devtools FPS meter to confirm mostly green frames.
 PRF-2: There are no major memory leaks or CPU hogs:
Playing several hands in a row doesn't increase memory continuously (monitored via Chrome performance or Safari timeline for memory – should stabilize after GC).
CPU usage returns to idle when no action (no busy loops). Verified by checking performance devtools timeline – idle time shows low CPU.
 PRF-3: Animation Budget adhered: We never have more than ~4-5 elements animating simultaneously:
Verified by code inspection and timeline that dealing flop does at most 3 card flips concurrently, chip moves not all at once.
Also confirmed by checking there's no layout thrash: e.g. timeline shows transform animations (compositor) rather than layout events each frame.
 PRF-4: Framer Motion usage optimized: No unnecessary rerenders during animations:
Verified by React DevTools Profiler that animating a card doesn't cause entire PokerGame to rerender (we ensure state updates are localized).
Timeline doesn't show repeated style recalculations or large scripting tasks when animating elements (like seat pulse is using CSS not JS heavy loop).
 PRF-5: Load Performance: The UI loads and becomes interactive quickly (likely within <2s on modern device):
Verified by Lighthouse or simply by refresh: the initial interface appears promptly and actions respond with minimal delay. This implies assets (images/sounds) are either preloaded or small enough not to block. If our audio is loaded on demand that might cause slight first use delay, but should be okay – ensure no excessive 3rd-party loads.
(If doing official measure, aim for Lighthouse Performance score ~90+, but if not measured, at least ensure no obvious blocking e.g. huge image downloads).
If all above criteria are satisfied (checked via a combination of automated tests, devtools inspections, and manual UX testing), the TeleHoldem UI implementation is considered complete and ready for production. Day 1–3 Execution Schedule:
Day 1:
Morning: Configure project (Tailwind breakpoints, CSS variables, safe-area support) and build the basic responsive layout containers in poker-game.tsx. Verify layout on a range of devices (using devtools Device Mode)
ux.stackexchange.com
.
Afternoon: Implement PlayerSeat component and seat positioning logic. Test seat arrangement on phone vs desktop and adjust constants for perfect spacing. Then implement ActionControls with dummy state logic and integrate into the page. By end of Day 1, we should have a visible table with seats and a functioning action bar (without real game state). Take snapshots at key widths to confirm layout.
Day 2:
Morning: Implement visuals for cards and community/pot. Create PlayingCard, CommunityCards, PotDisplay and ensure the flop etc. can render. Hook up the "Start Hand" button to simulate dealing (update phase and community cards state). Test the animations for dealing/flipping cards, refine the timing and CSS for smoothness.
Midday: Implement interactive extras: FloatingActionMenu and BottomSheet for stats/history. Integrate HandStrengthIndicator and a stubbed HistoryPanel. Ensure they toggle on mobile and panels display on desktop. Test toggling panels, swiping down to close sheet.
Afternoon: Add haptic feedback and sound triggers into action handlers and animations. Fine-tune volumes and haptic patterns. Conduct thorough device testing: at least run on an iPhone (or simulator) to feel haptics and see safe-area usage, and on an Android device for any webview quirks. Address any issues (e.g. adjust safe-area padding if something was off, fix focus if needed). By end of Day 2, core functionality and polish should be in place.
Day 3:
Morning: Accessibility audit – run Axe DevTools, fix any labeled issues. Manually test with VoiceOver/NVDA step by step as in criteria. Fix labeling or announce logic as needed (e.g. add aria-live tags or aria-labels found missing).
Midday: Performance profiling – use Chrome devtools Performance on key interactions (deal, bets). Optimize any heavy tasks (e.g. if we see a layout thrash, adjust code or CSS). Also test memory by simulating multiple rounds to ensure no leaks. Enable prefers-reduced-motion in devtools to ensure motion reduction works and adjust any missing cases (maybe turn off seat pulse via CSS media query).
Afternoon: Final QA run-through – execute the full QA checklist (section 8) on all target devices or emulators. Take final snapshots and diff against baseline. Any discrepancy or bug discovered at this stage is addressed immediately (e.g. a button not focusable, or sound not playing in Safari – fix it). After verifying all acceptance criteria pass, prepare build for release.
Following this schedule, by end of Day 3 we expect to have iteratively built, tested, and refined the TeleHoldem UI to meet the defined success criteria. Each step’s completion is confirmed by specific tests or observations as listed, ensuring confidence in the final product’s quality and readiness.
<!--
Roadmap Wrapper (Added by engineering)
This section organizes the existing instructions below into an actionable, checkbox‑driven plan without altering any of the content that follows. Do not edit the original instructions; use this tracker to manage execution.
-->

# Execution Roadmap (Tracker)

Use this checklist to drive implementation. Each item references a section name that already exists in this document. Mark items complete as you deliver them. Do not modify the original instruction content below.

- [x] 1. Information Architecture
  - [x] Confirm single‑page game layout and component ownership
  - [x] Verify side‑panel behavior at breakpoints (Hand Strength, History/Stats)
  - [x] Ensure MobileBottomSheet and FloatingActionMenu paths are wired

- [x] 2. Visual System and Tokens
  - [x] Lock typography scale per breakpoint (xs/sm/md/lg)
  - [x] Map tokens to client/src/index.css variables; verify light/dark
  - [x] Define elevation/blur/radius and apply to action bar/panels

- [x] 3. Layout and Breakpoints
  - [x] Apply table aspect ratios per viewport and safe‑area paddings
  - [x] Finalize seat placement (ellipse radius/scale per width)
  - [x] Hide/show side panels as specified

- [x] 4. Component Specs (APIs/behavior)
  - [x] PlayerSeat, PlayingCard, ActionControls, CommunityCards, PotDisplay, HandStrengthIndicator
  - [x] Keyboard shortcuts and swipe gestures
  - [x] Edge states: folded, all‑in, out‑of‑chips

- [ ] 5. Gestures, Haptics, and Sound
  - [ ] Swipe thresholds, draggable chips, haptic types, sound cues

- [x] 6. Accessibility Plan (WCAG 2.1 AA)
  - [x] Contrast, focus order, aria names, aria‑live for toasts (focus-visible, skip link, live regions present)
  - [x] Text scaling and truncation rules

- [ ] 7. Performance and Animations Budget
  - [ ] Transform‑only animations, motion‑reduce handling
  - [ ] Profiling and frame budget verification

- [ ] 8. QA Strategy
  - [x] Device matrix runs and screenshot protocol (baseline captured via scripts/snapshots.ts)
  - [ ] Safe‑area checks, button sizes, turn indicators
  - [ ] Accessibility and performance checks

- [ ] 9. References to Working Patterns
  - [ ] Document rationales borrowed from known apps/guides

- [ ] 10. Implementation Plan (Sequenced tasks)
  - [ ] Execute the ordered steps exactly as specified below
  - [ ] After each step, run snapshots and log acceptance evidence

- [ ] 11. Acceptance Criteria
  - [ ] Convert criteria to pass/fail checks with screenshot evidence

## Working Notes

- UI Dev server: `npm run dev:ui` (http://localhost:5173)
- Screenshot suite: `npm run snapshots:setup` (first run) then `npm run snapshots` (outputs to `snapshots/`)
- Do not alter the instruction text below. All implementation must conform to it.

### Progress Log
- 2025-10-26: Implemented Tasks 1.1–1.4 (mobile fixes), responsive seat scaling, table aspect tuning, side panels behavior; added Playwright snapshot harness and captured baseline screenshots across phone/tablet/desktop. Updated tracker accordingly.
- 2025-10-26: Locked responsive typography tokens and applied body scale; verified light/dark token mapping and elevation/blur usage on action bar/panels; added/validated skip link, focus-visible outlines, and live regions. Marked corresponding tracker items.
- 2025-10-26: Component specs pass — added aria roles/labels to PlayingCard (role="img" + descriptive label) and HandStrengthIndicator (role="status"), added group labeling for ActionControls, ensured truncation for long player names in PlayerSeat, confirmed existing keyboard shortcuts and swipe gestures. Completed Accessibility text scaling/truncation rules.

---
